#+title: My Emacs Configuration
#+options: ^:{} html-postamble:nil
#+property: header-args :mkdirp yes :tangle yes :tangle-mode: #o444 :results silent :noweb yes :comments link
#+archive: archives/%s::datetree/
#+startup: noindent overview hidedrawers

* Intro
A literate configuration for =Emacs=.

* Early-init.el
:PROPERTIES:
:header-args: :tangle-mode: #o444 :comments link :tangle ./early-init.el
:END:

** early-init start

#+begin_src emacs-lisp :lexical t
;;; early-init.el --- settings before frame initialize -*- lexical-binding: t no-byte-compile: t -*-
;;; Commentary:
;;; Code:
#+end_src

** package.el

disable builtin package.el, use borg instead
#+begin_src emacs-lisp :lexical t
(setq package-enable-at-startup nil)
(setq package-quickstart nil)
#+end_src

** frame init

Implicitly resizing the Emacs frame adds to init time.
Fonts larger than the system default can cause frame resizing, which adds to startup time.
#+begin_src emacs-lisp :lexical t
(setq frame-inhibit-implied-resize t)
#+end_src

frame position in pixels, SEE [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Frame-Layout.html#index-frame_002dedges][frame edge calculation]]
(frame-edges nil 'outer-edges)
= "outer-border" + (frame-edges nil 'native-edges)
= "outer-border" + "internal-border" + (frame-edges nil 'inner-edges)

frame width in pixels, SEE [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Layout-Parameters.html][frame width in pixels calculation]]
(frame-outer-width)
= (frame-native-width) + "external-border,gui only"|"outer-border,child-frame or tooltip only"
= (frame-internal-border-width)|(frame-border-width) + (frame-inner-width)
= (frame-internal-border-width)|(frame-border-width) + (frame-scroll-bar-width) + (frame-fringe-width) + (frame-text-width)|(frame-width)

margin belong to buffer, fringe belong to windows frame, SEE [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Fringe-Size_002fPos.html][frame width calculation]]
(frame-width) = (window-margins) + "maximal column number"

setup frame properties
#+begin_src emacs-lisp :lexical t
(setq frame-title-format
      '((:eval (concat (if (buffer-file-name) "%f" "%b")
                       (and (buffer-modified-p) " *")))))

(setq default-frame-alist
      '((menu-bar-lines . 0)
        (tool-bar-lines . 0)
        (vertical-scroll-bars . nil)
        (horizontal-scroll-bars . nil)
        (fullscreen . fullheight)
        ;; (left-fringe . 2)
        ;; (right-fringe . 2)
        ;; (internal-border-width . 0)

        ;; (width . 90) ; (frame-text-width) half 90,full 180
        ;; (background-mode . dark)
        ;; (alpha . (98 . 100))

        ;; NOTE only work in X-windows
        ;; (alpha-background . 20)
        ))
#+end_src

** system cofig

MacOs related
#+begin_src emacs-lisp :lexical t
(when (featurep 'ns)
  ;; disable icon and text in frame title
  (setq ns-use-proxy-icon nil)
  (push '(ns-transparent-titlebar . t) default-frame-alist)
  ;; (push '(ns-appearance . dark) default-frame-alist)
  (push '(ns-use-native-fullscreen . nil) default-frame-alist))

(when (featurep 'mac)

  ;; SEE https://gist.github.com/railwaycat/3498096
  (setq mac-option-modifier 'meta
        mac-command-modifier 'hyper)

  ;; HACK https://emacs-china.org/t/emacs-mac-port/15056/3?u=cheunghsu
  (set-face-background 'default "#1d252c")
  (dolist (f (face-list)) (set-face-stipple f "alpha:40%"))
  (setq face-remapping-alist (append face-remapping-alist '((default my/default-blurred))))
  (defface my/default-blurred
    '((t :inherit 'default :stipple "alpha:40%"))
    "Like 'default but blurred."
    :group 'my))
#+end_src

** early-init end

#+begin_src emacs-lisp :lexical t
(provide 'early-init)
;;; early-init.el ends here
#+end_src

* Init-mini.el
:PROPERTIES:
:header-args: :tangle-mode: #o444 :comments link :tangle ./init-mini.el
:END:

** init-mini start

#+begin_src emacs-lisp :lexical t
;;; init-mini.el --- minimal startup  -*- lexical-binding: t no-byte-compile: t -*-
;;; Commentary:
;;; Code:
#+end_src

** native-compile

setup native compiling

#+begin_src emacs-lisp :lexical t
(when (featurep 'native-compile)
  (setq native-comp-speed 2)
  (setq native-comp-async-jobs-number 6)
  (setq native-comp-jit-compilation t)
  (setq native-comp-async-report-warnings-errors nil)

  ;; change eln-cache position
  ;; (when (fboundp 'startup-redirect-eln-cache)
  ;;   (startup-redirect-eln-cache
  ;;    (convert-standard-filename
  ;;     (expand-file-name  ".cache/var/eln-cache/" user-emacs-directory))))
  )
#+end_src

** startup

do not show default welcome message

#+begin_src emacs-lisp :lexical t
(setq inhibit-startup-screen t
      inhibit-startup-echo-area-message (user-login-name)
      initial-scratch-message nil
      inhibit-default-init t
      auto-save-list-file-prefix nil)
(setq site-run-file nil)
(setq load-prefer-newer t)
(advice-add #'display-startup-echo-area-message :override #'ignore)
#+end_src

** optimisation

improve performance of long line, SEE https://emacs-china.org/t/topic/25811/7

#+begin_src emacs-lisp :lexical t
(setq-default bidi-display-reordering nil)
(setq bidi-inhibit-bpa t
      long-line-threshold 1000
      large-hscroll-threshold 1000
      syntax-wholeline-max 1000)
#+end_src

** font

setup font
#+begin_src emacs-lisp :lexical t
(defvar my/default-font "LXGW WenKai Mono Light 17")
(defvar my/chinese-font-family "LXGW WenKai Mono")

;; setup default frame
(add-to-list 'default-frame-alist `(font . ,my/default-font))
;; (set-fontset-font "fontset-default" 'unicode "Symbols Nerd Font Mono-17")
;; ;; setup chinese patch
;; (defun my/patch-chinese-charset ()
;;   "Patch chinese character with lxgw font."
;;   `(dolist (charset '(kana han symbol cjk-misc bopomofo))
;;     (set-fontset-font
;;      ;; "fontset-startup"
;;      (frame-parameter nil 'font)
;;      charset
;;      (font-spec :family ,my/chinese-font-family))))
;; (add-hook 'after-make-graphic-frame-hook #'my/patch-chinese-charset)
#+end_src

** encode

#+begin_src emacs-lisp :lexical t
(define-coding-system-alias 'UTF-8 'utf-8)
(when (fboundp 'set-charset-priority)
  (set-charset-priority 'unicode))
(prefer-coding-system 'utf-8)
(setq locale-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
#+end_src

** protection

set file read-only if file locates in =lisp-directory=
#+begin_src emacs-lisp :lexical t
(defun lisp-directory-read-only ()
  "Set all built-in library read-only."
  (when (file-in-directory-p buffer-file-name lisp-directory)
    (read-only-mode)))
(add-hook #'find-file-hook #'lisp-directory-read-only)
#+end_src

** disabled

cancel disable property for some commands
#+begin_src emacs-lisp :lexical t
(defvar disabled-command-list '(set-goal-column help-fns-edit-variable))
(mapatoms (lambda (sym)
            (when (and (commandp sym)
                       (get sym 'disabled)
                       (not (member sym disabled-command-list)))
              (put sym 'disabled nil))))
#+end_src

** misc

#+begin_src emacs-lisp :lexical t
(setq y-or-n-p-use-read-key t)
(setq source-directory "~/Library/Caches/Homebrew/emacs-head@31--git")
(setq use-short-answers t
      use-file-dialog nil
      use-dialog-box nil
      echo-keystrokes 0.02
      ad-redefinition-action 'accept
      inhibit-compacting-font-caches t
      window-resize-pixelwise t
      frame-resize-pixelwise t
      ring-bell-function 'ignore
      history-length 1000
      history-delete-duplicates t
      word-wrap-by-category t)

(setq-default tab-width 4
              fill-column 85
              fringe-indicator-alist nil
              ;; fringes-outside-margins nil
              ;; left-margin-width 1
              ;; right-margin-width 1
              line-spacing 0.15
              default-directory "~")

;; ;; SEE https://emacs.stackexchange.com/a/2555/35676;9u
;; (setq-default major-mode
;;               (lambda () (if buffer-file-name
;;                              (fundamental-mode)
;;                            (let ((buffer-file-name (buffer-name)))
;;                              (set-auto-mode)))))

;; Increase how much is read from processes in a single chunk (default is 4kb)
(setq read-process-output-max #x10000)  ; 64kb

;; Don't ping things that look like domain names.
(setq ffap-machine-p-known 'reject)
#+end_src

** warning

suppress unneed warnings
#+begin_src emacs-lisp :lexical t
(setq byte-compile-warnings '(not docstrings free-vars obsolete))
(dolist (func '(define-minor-mode))
  (advice-add func :around #'ad/silent-message))
#+end_src

** custom variables

create dirs if not exists
#+begin_src emacs-lisp :lexical t
(defconst my/dir-lisp
  (expand-file-name "lisp/" user-emacs-directory)
  "User dir for external tools.")

(defconst my/dir-etc
  (expand-file-name "etc/" user-emacs-directory)
  "User dir for external tools.")

(defconst my/dir-cache
  (expand-file-name ".cache/" user-emacs-directory)
  "User dir for recentf,places and so on.")

(defconst my/dir-debug
  (expand-file-name "debug/" my/dir-cache)
  "User dir for minimal debugging config.")

(defconst my/file-debug
  (expand-file-name "debug-default.el" my/dir-debug)
  "Default file for debug.")

(defconst my/init-org
  (expand-file-name "init.org" user-emacs-directory)
  "User dir for minimal debugging config.")

(defconst my/dir-org
  (expand-file-name "org/" "~/Documents")
  "User dir for minimal debugging config.")

;; ensure dir exists
(dolist (dir `(,my/dir-cache
               ,my/dir-etc
               ,my/dir-debug
               ,my/dir-lisp
               ,my/dir-org))
  (make-directory dir t))
#+end_src

Packages that I'm developing or aren't part of any online repositories go in =~/.config/emacs/lisp/=.

#+begin_src emacs-lisp :lexical t
(let ((default-directory my/dir-lisp))
  (when (file-exists-p default-directory)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path)))
#+end_src

load custom files
#+begin_src emacs-lisp :lexical t
;; load custom.el if exists.
(setq custom-file (expand-file-name "etc/custom.el" my/dir-cache))
(when (file-exists-p custom-file)
  (load custom-file nil :no-message))
#+end_src

load private informations if exists
#+begin_src emacs-lisp :lexical t
(setq private-file (expand-file-name "etc/private.el" my/dir-cache))
(when (file-exists-p private-file)
  (load private-file nil :no-message))
#+end_src

** library
*** vars
#+begin_src emacs-lisp :lexical t
(defconst emacs-preload-features (reverse features)
  "Emacs preload features by default.")

(defconst sys/win32p
  (eq system-type 'windows-nt)
  "Are we running on a WinTel system?")

(defconst sys/linuxp
  (eq system-type 'gnu/linux)
  "Are we running on a GNU/Linux system?")

(defconst sys/macp
  (eq system-type 'darwin)
  "Are we running on a Mac system?")

(defconst sys/mac-x-p
  (and (display-graphic-p) sys/macp)
  "Are we running under X on a Mac system?")

(defconst sys/mac-ns-p
  (eq window-system 'ns)
  "Are we running on a GNUstep or Macintosh Cocoa display?")

(defconst sys/mac-cocoa-p
  (featurep 'cocoa)
  "Are we running with Cocoa on a Mac system?")

(defconst sys/linux-x-p
  (and (display-graphic-p) sys/linuxp)
  "Are we running under X on a GNU/Linux system?")

(defconst sys/cygwinp
  (eq system-type 'cygwin)
  "Are we running on a Cygwin system?")

(defconst sys/rootp
  (string-equal "root" (getenv "USER"))
  "Are you using ROOT user?")

(defconst emacs/>=30p
  (>= emacs-major-version 30)
  "Emacs is 30 or above.")

(defconst emacs/>=30p
  (>= emacs-major-version 31)
  "Emacs is 31 or above.")

(defconst emacs/>=29.1p
  (or emacs/>=30p
      (and (= emacs-major-version 29)
           (>= emacs-minor-version 1)))
  "Emacs is 29.1 or above.")
#+end_src

*** macros

#+begin_src emacs-lisp :lexical t
(defmacro message! (arg)
  "Echo `ARG' info."
  `(message (concat "[" (symbol-name ',arg) "] >> TYPE: %s , VALUE: %s ")
            (type-of (symbol-value ',arg)) ,arg))

(defmacro time-count! (&rest body)
  "Measure the time (ms) it takes evaluating BODY."
  `(let ((time (current-time)))
     ,@body
     (* 1000.0 (float-time (time-since time)))))

(defmacro appendq! (sym &rest lists)
  "Append LISTS to SYM in place."
  `(setq ,sym (append ,sym ,@lists)))

(defmacro prependq! (sym &rest lists)
  "Prepend LISTS to SYM in place."
  `(setq ,sym (append ,@lists ,sym)))

(defmacro alist-set! (sym alist)
  "For each element of ALIST, add or replace it in SYM.
Add the element to SYM when there is no match whose `car' equals element's
`car'.  Replace the element in SYM when there is match."
  `(mapc (lambda (x) (setf (alist-get (car x) ,sym) (cdr x))) ,alist))

(defmacro run-general! (fn-r fn)
  "Expand as one command to rule all.
FN-R : region function, FN: default function"
  `(if (use-region-p)
       (funcall ',fn-r (region-beginning) (region-end))
     (funcall ',fn)))

(defmacro defun-mixed! (func-name thing-type prompt body)
  ""
  `(defun ,func-name ()
     (interactive)
     (let* ((sym-here (thing-at-point ',thing-type t))
            (default-val
             (if sym-here
                 (format
                  (propertize "(default %s)" 'face 'font-lock-doc-face)
                  (propertize sym-here 'face 'font-lock-variable-name-face))
               ""))
            (query (if (use-region-p)
                       (buffer-substring-no-properties
                        (region-beginning)
                        (region-end))
                     (read-string
                      (format "%s %s: " ,prompt default-val)
                      nil nil sym-here))))
       ,body)))
#+end_src

*** functions
#+begin_src emacs-lisp :lexical t
(defvar minor-fallback-alist
  '((read-only-mode . buffer-read-only)
    (save-place-local-mode . save-place-mode)))

(defun minor-mode-p (mode)
  "Return t if MODE is a minor mode."
  (and (functionp mode)
       (progn
         (when (autoloadp (symbol-function mode))
           (load (cdr (find-function-library mode)) nil t))
         (memq (or (alist-get mode minor-fallback-alist) mode) minor-mode-list))))

;; (defun major-mode-p (sym)
;;   "Return t if SYM is a major mode."
;;   (and (functionp sym)
;;        (string-match-p "-mode$" (symbol-name sym))
;;        (autoload-do-load (symbol-function sym))
;;        (seq-some (lambda (p) (get sym p))
;;                  '(derived-mode-parent
;;                    derived-mode-extra-parents
;;                    derived-mode--all-parents
;;                    derived-mode--followers))
;;        t))

(defun get-major-mode-for-file (filename)
  "Return the major mode for FILENAME, including shebang check."
  (with-temp-buffer
    (let ((buffer-file-name (expand-file-name filename)))
      (when (file-readable-p filename)
        (insert-file-contents filename nil 0 100))
      (set-auto-mode)
      major-mode)))

(defun feature-preload-p (feature)
  "Return non-nil if FEATURE is pre-loaded by default."
  (and emacs-preload-features
       (memq feature emacs-preload-features)))

(defun my/major-mode-list ()
  "Return major mode list."
  (mapcar #'symbol-name
          (seq-filter #'commandp
                      (seq-uniq (map-values auto-mode-alist)))))

(defun adjust-font-family-buffer-local (font-family)
  "Set FONT-FAMILY in current buffer only."
  (interactive (list (completing-read "font family:" (font-family-list))))
  (setq buffer-face-mode-face `(:family ,font-family))
  (buffer-face-mode))

;; TODO write buffer-info-dispatch to show, copy and change buffer status
;; Dos2Unix/Unix2Dos
(defun dos2unix ()
  "Convert the current buffer to UNIX file format."
  (interactive)
  (set-buffer-file-coding-system 'undecided-unix nil))

(defun unix2dos ()
  "Convert the current buffer to DOS file format."
  (interactive)
  (set-buffer-file-coding-system 'undecided-dos nil))

(defun delete-carrage-returns ()
  "Delete `^M' characters in the buffer.
Same as `replace-string C-q C-m RET RET'."
  (interactive)
  (save-excursion
    (goto-char 0)
    (while (search-forward "\r" nil :noerror)
      (replace-match ""))))


;; File and buffer

(defun my/temp-file (suffix)
  "Switch to temp file with SUFFIX."
  (interactive
   (list (read-string "Select file kind : ")))
  (let ((file-name (expand-file-name (concat "Temp/temp." suffix) my/dir-cache)))
    (with-current-buffer (find-file file-name)
      (delete-region (point-min) (point-max)))))

(defun revert-this-buffer ()
  "Revert the current buffer."
  (interactive)
  (unless (minibuffer-window-active-p (selected-window))
    (revert-buffer t t)
    (message "Reverted this buffer")))

(defun delete-both ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (unless (buffer-file-name)
    (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))

(defun rename-both (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (progn
      (when (file-exists-p filename)
        (rename-file filename new-name 1))
      (set-visited-file-name new-name)
      (rename-buffer new-name))))

(defun rename-this-file (new-name)
  "Renames current file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (when (file-exists-p filename)
      (rename-file filename new-name 1))))

(defun file-absolute-path ()
  "Return visited file absolute-path."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (unless filename
      (error "Buffer '%s' is not visiting a file!" name))
    (message "File Path: '%s' " filename)
    (kill-new filename)))

(defun buffer-base-name ()
  "Return buffer name."
  (interactive)
  (let ((name (buffer-name)))
    (message "Buffer name: '%s' " name)
    (kill-new name)))

(defun browse-this-file ()
  "Open the current file as a URL using `browse-url'."
  (interactive)
  (let ((file-name (buffer-file-name)))
    (if (and (fboundp 'tramp-tramp-file-p)
             (tramp-tramp-file-p file-name))
        (error "Cannot open tramp file")
      (browse-url (concat "file://" file-name)))))

(defun copy-file-name ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (if-let* ((filename (if (equal major-mode 'dired-mode)
                          default-directory
                        (buffer-file-name))))
      (progn
        (kill-new filename)
        (message "Copied '%s'" filename))
    (message "WARNING: Current buffer is not attached to a file!")))

(defun reload-init-file ()
  "Reload Emacs configurations."
  (interactive)
  (load user-init-file))

(defun save-buffer-as-utf8 (coding-system)
  "Revert a buffer with `CODING-SYSTEM' and save as UTF-8."
  (interactive "zCoding system for visited file (default nil):")
  (revert-buffer-with-coding-system coding-system)
  (set-buffer-file-coding-system 'utf-8)
  (save-buffer))

(defun save-buffer-gbk-as-utf8 ()
  "Revert a buffer with GBK and save as UTF-8."
  (interactive)
  (save-buffer-as-utf8 'gbk))

(defun save-and-kill ()
  "Save and kill current buffer."
  (interactive)
  (let ((kill-buffer-query-functions nil))
    (save-buffer)
    (kill-buffer nil)))

(defun kill-buffer-silently ()
  "Kill current buffer silently."
  (interactive)
  (let ((kill-buffer-query-functions nil))
    (kill-buffer nil)))

(defun ad/silent-message (original &rest args)
  "Silent function `ORIGINAL' message."
  (let ((inhibit-message t)
        (message-log-max nil))
    (apply original args)))

(defun indent-whole-buffer ()
  "Indent whole buffer."
  (interactive)
  (let ((begin (point-min))
        (end (point-max)))
    (indent-region begin end nil)
    (whitespace-cleanup-region begin end)))

(defun indent-dir-files (dir ext)
  "Formatting files with EXT in DIR."
  (interactive (list (read-directory-name "Directory: ")
                     (read-string "File extension: " ".")))
  (let ((bufs (buffer-list))
        (cur (current-buffer)))
    (dolist (file (directory-files-recursively dir ext))
      (find-file file)
      (indent-region (point-min) (point-max))
      (save-buffer)
      (unless (member (get-file-buffer file) bufs)
        (kill-buffer nil)))
    (switch-to-buffer cur)))

(defun toggle-profiler ()
  "Start,stop or report in one command."
  (interactive)
  (if (not (or (profiler-cpu-running-p) (profiler-memory-running-p)))
      (profiler-start 'cpu+mem)
    (profiler-stop)
    (profiler-report)))

(defun cjk-font-setting (font scale)
  "Set cjk `FONT' with `SCALE'."
  (dolist (charset '(kana han symbol cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font)
                      charset (font-spec :family font))
    (setq face-font-rescale-alist '((font . scale)))))

(defun open-in-other-window (&rest _)
  "Open in other window."
  (switch-to-buffer-other-window (current-buffer)))

(defun tty-frame-list ()
  "Return a list of all tty frames, except the daemon <frame F1>."
  (seq-filter (lambda (f) (frame-parameter f 'tty))
              (frame-list)))

(defun gui-frame-list ()
  "Return a list of all non-child gui frames."
  (seq-filter (lambda (f)
                (and (frame-parameter f 'display)
                     (null (frame-parameter f 'parent-frame))))
              (frame-list)))

(defun shell-command-exit-code-and-output (program &rest args)
  "Run PROGRAM with ARGS and return the exit code and output in a cons."
  (with-temp-buffer
    (cons (apply 'call-process program nil (current-buffer) nil args)
          (buffer-string))))

;; SEE https://www.emacswiki.org/emacs/AsciiTable
(defun ascii-table ()
  "Display basic ASCII table (0 thru 128)."
  (interactive)
  (switch-to-buffer "*ASCII*")
  (erase-buffer)
  (setq buffer-read-only nil)
  (local-set-key "q" 'bury-buffer)
  (save-excursion
    (let ((i -1))
      (insert "ASCII characters 0 to 127.\n\n")
      (insert (apply #'concat (make-list 4 " Char  Oct  Dec  Hex |")) "\n")
      (while (< i 31)
        (insert (format (apply
                         #'concat
                         (make-list 4 (mapconcat
                                       (lambda (pair)
                                         (propertize (car pair) 'face (cdr pair)))
                                       '((" %4s" . font-lock-keyword-face)
                                         (" %4o" . font-lock-comment-face)
                                         (" %4d" . font-lock-variable-name-face)
                                         (" %4x |" . default)))))
                        (single-key-description (setq i (+ 1  i))) i i i
                        (single-key-description (setq i (+ 32 i))) i i i
                        (single-key-description (setq i (+ 32 i))) i i i
                        (single-key-description (setq i (+ 32 i))) i i i)
                "\n")
        (setq i (- i 96))))))

;; stock deviation
(defun stock-5p (price)
  (let (lst)
    (dolist (l (number-sequence -5 5 0.5))
      (and (zerop l) (push "+++++++++++" lst))
      (push (format "%+4.1f%%  %.2f" l (/ (* (+ 100 l) price) 100)) lst)
      (and (zerop l) (push "-----------" lst)))
    (string-join lst "\n")))

(defun org-diary-template-for-stock ()
  (if-let* ((lst stocks-in-hand))
      (mapconcat (lambda (s) (format "**** %s\n- 预测:\n- 对策:\n- 结果:\n" s)) lst "\n")
    "- "))


(defun temp-log (msg)
  (with-current-buffer (get-buffer-create " *temp-log*")
    (unless (derived-mode-p 'special-mode)
      (special-mode))
    (goto-char (point-max))
    (let ((inhibit-read-only t))
      (insert msg)
      (newline 2))))

(defun my/load-features (&rest features)
  "Loading FEATURES and print log if error happens."
  (dolist (f features)
    (condition-case err
        (require f)
      (t (temp-log (format "%s\n%-10s: %s\n%-10s: %s"
                           (propertize "[init-require-feature]" 'face 'error)
                           "feature" (symbol-name f)
                           "error" (error-message-string err)))))))


;;; Debug
;;; TODO miniconfig package

(defun my/debug-begin-p ()
  "Return t if mininal debug begin."
  (and (file-exists-p my/file-debug)
       (> (nth 7 (file-attributes my/file-debug)) 0)))

(defun my/debug-begin ()
  "Begin debug with existed config or new one."
  (interactive)
  (my/debug-end)
  (let* ((new my/file-debug)
         (dir (expand-file-name "backup/" my/dir-debug))
         ;; (dir (make-directory (expand-file-name "backup/" my/dir-debug) t))
         (select (and (file-exists-p dir)
                      (not (directory-empty-p dir))
                      (yes-or-no-p "Select existed config? ")))
         (old (and select (condition-case nil
                              (read-file-name "Debug config: " dir "")
                            (quit "")))))
    (if (length> old 0)
        (copy-file old new 'overwrite)
      (make-empty-file new))
    (display-buffer (find-file-noselect new))))

(defun my/debug-add ()
  "Copy selected config to `my/file-debug'."
  (interactive)
  (let* ((f my/file-debug)
         (buf (or (get-file-buffer f)
                  (find-file-noselect f)))
         (pos (save-excursion
                (if (use-region-p)
                    (cons (region-beginning) (region-end))
                  (condition-case _err
                      (while (not (looking-at "(use-package "))
                        (backward-up-list 1))
                    (error nil))
                  (cons (line-beginning-position) (scan-sexps (point) 1)))))
         (str (buffer-substring-no-properties (car pos) (cdr pos))))
    (with-current-buffer buf
      (goto-char (point-max))
      (insert (format "\n%s\n" str))
      (indent-region (point-min) (point-max))
      (emacs-lisp-mode)
      (save-buffer)
      (display-buffer buf))))

(defun my/debug-end ()
  "Exit debug process."
  (interactive)
  (let* ((buf (get-file-buffer my/file-debug))
         (win (get-buffer-window buf)))
    (ignore-errors
      (and buf win (delete-window win))
      (and buf (kill-buffer buf))
      (delete-file my/file-debug))))

(defun my/debug-backup ()
  "Backup minimal config file."
  (interactive)
  (if (my/debug-begin-p)
      (let* ((default-directory (expand-file-name "backup/" my/dir-debug))
             (old my/file-debug)
             (new (condition-case nil
                      (read-from-minibuffer
                       (format "Backup %s to debug-*.el: "
                               (file-name-nondirectory old)))
                    (quit ""))))
        (if (string-empty-p new)
            (message "File name is illegal.")
          (make-directory default-directory t)
          (copy-file old (concat "debug-" new ".el") 1)))
    (message "Debug hasn't begined yet.")))
#+end_src

*** hooks

define hooks for frames
#+begin_src emacs-lisp :lexical t

;; (defvar after-load-theme-hook nil
;;   "Hook run after a color theme is loaded using `load-theme'.")
;; (defun run-after-load-theme-hook (&rest _)
;;   "Run `after-load-theme-hook'."
;;   (run-hooks 'after-load-theme-hook))
;; (advice-add #'load-theme :after #'run-after-load-theme-hook)

(defun av/update-frame-title-foreground (theme &rest _)
  "Advice for update frame tile foreground when load THEME."
  (when (featurep 'ns)
    (modify-all-frames-parameters
     (list (cons 'ns-appearance
                 ;; FIXME failed on doom-*-themes
                 (or (plist-get (get theme 'theme-properties) :background-mode) 'dark))))))
(advice-add #'load-theme :after #'av/update-frame-title-foreground)

(defvar after-make-console-frame-hook '()
  "Hooks to run after creating a new TTY frame.")

(defvar after-make-graphic-frame-hook '()
  "Hooks to run after creating a new graphic frame.")

(defun my/frame-setup ()
  "Setup for frame related hooks."
  (run-hooks (if (display-graphic-p)
                 'after-make-graphic-frame-hook
               'after-make-console-frame-hook)))
(add-hook 'server-after-make-frame-hook #'my/frame-setup)

(defun my/frame-no-server-setup (frame)
  "Run configured hooks in response to the newly-created FRAME.
Selectively runs either `after-make-console-frame-hooks' or
`after-make-graphic-frame-hooks'"
  (unless (daemonp)
    (with-selected-frame frame
      (my/frame-setup))))
(add-hook 'after-make-frame-functions 'my/frame-no-server-setup)

(defconst my/initial-frame (selected-frame)
  "The frame (if any) active during Emacs initialization.")
(add-hook 'after-init-hook
          (lambda () (when my/initial-frame
                       (my/frame-no-server-setup my/initial-frame))))
#+end_src

** init-mini end

#+begin_src emacs-lisp :lexical t
(provide 'init-mini)
;;; init-mini.el ends here
#+end_src

* Init.el
:PROPERTIES:
:header-args: :tangle-mode: #o444 :comments link :tangle ./init.el
:END:

** init start

#+begin_src emacs-lisp :lexical t
;;; init.el --- init startup  -*- lexical-binding: t no-byte-compile: t -*-
#+end_src

** load mini

#+begin_src emacs-lisp :lexical t
(load-file (expand-file-name "init-mini.el" user-emacs-directory))
#+end_src

** debugging

Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package (perhaps earlier than you want).
Use by tangling this block and launching Emacs with =emacs --debug-init=.

#+begin_src emacs-lisp :var file="" :results silent :tangle no
;; (unless (string-empty-p file)
;;   (eval-after-load file
;;     '(debug)))
(debug-on-entry 'load-file)
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.
#+begin_src emacs-lisp :tangle no
(setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.
#+begin_src emacs-lisp :tangle no
(debug-on-variable-change VAR)
(add-variable-watcher 'org-capture-after-finalize-hook
                      (lambda (symbol newval operation where)
                        (debug)
                        (message "%s set to %s" symbol newval)))
#+end_src

#+begin_src emacs-lisp :tangle no
(setq debug-on-error t)
#+end_src

** gc

=gc-cons-threshold= (800 KB) and =gc-cons-percentage= (0.1) control when the Emacs garbage collector can kick in.
Temporarily turning these off during init should decrease startup time.
Resetting them afterward will ensure that normal operations don't suffer from a large GC periods.

#+begin_src emacs-lisp :lexical t
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun my/restore-gc-val ()
  "Recover GC values after startup."
  (setq gc-cons-threshold 800000
        gc-cons-percentage 0.1
        file-name-handler-alist default-file-name-handler-alist))
(add-hook 'after-init-hook #'my/restore-gc-val)
#+end_src

** statistic
*** startup time

show how much time used in emacs startup
#+begin_src emacs-lisp :lexical t
(defun my/show-startup-time ()
  (message "Emacs loaded in %.2f seconds with %d garbage collections."
           (float-time (time-subtract after-init-time before-init-time))
           gcs-done))
(add-hook 'after-init-hook #'my/show-startup-time)
#+end_src

*** profile report

show profile report if needed
#+begin_src emacs-lisp :lexical t :tangle no
(profiler-start 'cpu+mem)
(add-hook 'after-init-hook (lambda () (profiler-stop) (profiler-report)))
#+end_src

*** elp report

elp is useful for seeing which functions in a package are "hot".
#+begin_src emacs-lisp :var file="use-package" :lexical t :tangle no
(require 'elp)
(with-eval-after-load file
  (elp-instrument-package file))
(add-hook 'after-init-hook
          (lambda () (elp-results) (elp-restore-package (intern file))))
#+end_src

** packages
:PROPERTIES:
:VISIBILITY: children
:END:
*** borg

#+begin_src emacs-lisp :lexical t
(add-to-list 'load-path (expand-file-name "lib/borg" user-emacs-directory))
(require 'borg)
(setq borg-rewrite-urls-alist
      '(("git@github.com:" . "https://github.com/")
        ("git@gitlab.com:" . "https://gitlab.com/")))
(setq borg-compile-function #'borg-byte+native-compile-async)
(borg-initialize)
#+end_src

*** auto-compile

#+BEGIN_SRC emacs-lisp :lexical t
(require 'compile)
(setq load-prefer-newer t)
(auto-compile-on-load-mode)
#+END_SRC

*** use-package

#+begin_src emacs-lisp :lexical t
(require 'use-package)
(setq use-package-hook-name-suffix nil
      use-package-always-ensure nil
      use-package-always-defer t
      use-package-enable-imenu-support t)
(if debug-on-error
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t
        use-package-compute-statistics nil))
#+end_src

*** benchmark-init

#+begin_src emacs-lisp :lexical t
(use-package benchmark-init
  :demand t
  :hook (after-init-hook . benchmark-init/deactivate)
  :init
  (with-eval-after-load 'benchmark-init-modes
    (keymap-set benchmark-init/tree-mode-map
                "t" #'benchmark-init/show-durations-tabulated)
    (keymap-set benchmark-init/tabulated-mode-map
                "t" #'benchmark-init/show-durations-tree))
  (add-hook 'benchmark-init/tabulated-mode-hook #'hl-line-mode))
#+end_src

*** gcmh

#+begin_src emacs-lisp :lexical t
(use-package gcmh
  :demand t
  :init
  (setq gcmh-idle-delay 5
        gcmh-high-cons-threshold #x1000000) ; 16MB
  :config
  (gcmh-mode 1))
#+end_src

*** no-littering

#+begin_src emacs-lisp :lexical t
(use-package no-littering
  :demand t
  :init
  (setq no-littering-etc-directory (expand-file-name "etc/" my/dir-cache)
        no-littering-var-directory (expand-file-name "var/" my/dir-cache))
  :config
  ;; ;; save auto-save file if needed
  ;; (setq auto-save-file-name-transforms
  ;;       `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))

  ;; DISCUSSION https://github.com/emacscollective/no-littering/discussions/164
  (when (fboundp 'lisp-data-mode)
    (prependq! auto-mode-alist
               `((,(concat (regexp-quote no-littering-etc-directory) ".*\\.el\\'")
                  . lisp-data-mode)
                 (,(concat (regexp-quote no-littering-var-directory) ".*\\.el\\'")
                  . lisp-data-mode))))

  ;; exclude these in recentf
  (with-eval-after-load 'recentf
    (appendq! recentf-exclude
              `(,no-littering-var-directory ,no-littering-etc-directory))))
#+end_src

*** exec-path-from-path                                                  :shell:

#+begin_src emacs-lisp :lexical t
(use-package exec-path-from-shell
  :demand t
  :hook (after-make-graphic-frame-hook . exec-path-from-shell-initialize))
#+end_src

*** server

make sure emacs server running
#+begin_src emacs-lisp :lexical t
(use-package server
  :hook (after-init-hook . server-or-daemon-setup)
  :init
  (setq server-client-instructions nil)
  (defun server-or-daemon-setup ()
    "Start server if not running."
    (require 'server)
    (unless (or (daemonp) (server-running-p))
      (server-start))))
#+end_src

*** which-key

#+begin_src emacs-lisp :lexical t
(use-package which-key
  :hook (after-init-hook . which-key-mode)
  :init
  (setq which-key-show-prefix 'top
        which-key-popup-type 'minibuffer
        which-key-preserve-window-configuration t
        which-key-max-description-length 45
        which-key-dont-use-unicode t
        which-key-idle-delay 0.6
        which-key-idle-secondary-delay 0.2))
#+end_src

*** mouse

#+begin_src emacs-lisp :lexical t
(use-package mouse
  :init
  (setq mouse-yank-at-point t))

(use-package xt-mouse

  :init
  (defun my/mouse-setup ()
    "enable mouse and keybindings in eamcs -nw"
    (xterm-mouse-mode)
    (keymap-global-set "<mouse-4>" (lambda ()
                                     (interactive)
                                     (scroll-down 1)))
    (keymap-global-set "<mouse-5>" (lambda ()
                                     (interactive)
                                     (scroll-up 1))))
  (add-hook 'after-make-console-frame-hook #'my/mouse-setup))

(use-package mwheel
  :config
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed nil))

(use-package pixel-scroll
  :hook (after-init-hook . pixel-scroll-precision-mode))
#+end_src

*** paragraph

#+begin_src emacs-lisp :lexical t
(use-package paragraphs
  :init
  (setq sentence-end-double-space nil))
#+end_src

*** display-line-number

#+begin_src emacs-lisp :lexical t :tangle no
(use-package display-line-numbers
  :hook (after-init-hook . global-display-line-numbers-mode)
  :init
  (setq display-line-numbers-grow-only t)

  ;; HACK only display line numbers in selected modes
  (advice-add 'display-line-numbers--turn-on
              :override #'av/display-line-numbers--turn-on)
  (defun av/display-line-numbers--turn-on ()
    (unless (or (minibufferp)
                (memq major-mode '(vterm-mode dired-mode dirvish-directory-view-mode
                                              eshell-mode term-mode org-mode))
                (derived-mode-p '(special-mode)))
      (display-line-numbers-mode))))
#+end_src

*** hl-line

#+begin_src emacs-lisp :lexical t :tangle no
(use-package hl-line
  :config
  (setq hl-line-sticky-flag nil)
  (setq global-hl-line-sticky-flag nil))
#+end_src

*** lin

#+begin_src emacs-lisp :lexical t
(use-package lin
  :hook (after-init-hook . lin-global-mode)
  :config
  (appendq! lin-mode-hooks
            '(prog-mode-hook text-mode-hook rg-mode-hook))
  (setq lin-face 'hl-line))
#+end_src

*** desktop

#+begin_src emacs-lisp :lexical t :tangle no
;; TODO multiple desktop settings,see
;; https://www.emacswiki.org/emacs/DesktopMultipleSaveFiles
;; https://stackoverflow.com/a/849180/13194984
(use-package desktop
  ;; :hook (after-init-hook . desktop-save-mode)
  :init
  (setq desktop-auto-save-timeout 600
        desktop-restore-frames nil)
  (setq desktop-globals-to-save
        '((comint-input-ring        . 50)
          (compile-history          . 30)
          desktop-missing-file-warning
          (dired-regexp-history     . 20)
          (extended-command-history . 30)
          (face-name-history        . 20)
          (file-name-history        . 100)
          (grep-find-history        . 30)
          (grep-history             . 30)
          (magit-revision-history   . 50)
          (minibuffer-history       . 50)
          (org-clock-history        . 50)
          (org-refile-history       . 50)
          (org-tags-history         . 50)
          (query-replace-history    . 60)
          (read-expression-history  . 60)
          (regexp-history           . 60)
          (regexp-search-ring       . 20)
          register-alist
          (search-ring              . 20)
          (shell-command-history    . 50)
          tags-file-name
          tags-table-list))

  :config
  (defun ad/desktop-time-restore (orig &rest args)
    "Count the restore time in total."
    (message "Desktop: %.2fms restored in TOTAL" (time-count! (apply orig args))))
  (advice-add 'desktop-read :around 'ad/desktop-time-restore)

  (defun ad/desktop-time-buffer-create (orig ver filename &rest args)
    "Count the buffer restored time."
    (message "Desktop: %.2fms to restore %s"
             (time-count! (apply orig ver filename args))
             (when filename
               (abbreviate-file-name filename))))
  (advice-add 'desktop-create-buffer :around 'ad/desktop-time-buffer-create))
#+end_src

*** simple

#+begin_src emacs-lisp :lexical t
(use-package simple
  :init
  (setq next-error-highlight t
        next-error-highlight-no-select t
        next-error-message-highlight t
        kill-whole-line t
        read-extended-command-predicate #'command-completion-default-include-p)
  (setq-default indent-tabs-mode nil)
  ;; SEE https://emacs-china.org/t/emacs29-blinking-cursor/23683
  (setq copy-region-blink-delay 0))
#+end_src

*** uniquify

#+begin_src emacs-lisp :lexical t
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"))

;; (use-package display-fill-column-indicator
;;   :hook (after-init-hook . global-display-fill-column-indicator-mode)
;;   :init
;;   ;; use white space character
;;   (setq-default display-fill-column-indicator-character ?\u0020))
#+end_src

*** tabulated-list

#+begin_src emacs-lisp :lexical t
(use-package tabulated-list
  :config
  (setq tabulated-list-gui-sort-indicator-asc ?⏶)   ;; "\u23F6"
  (setq tabulated-list-gui-sort-indicator-desc ?⏷)) ;; "\u23F7"
#+end_src

*** files

#+begin_src emacs-lisp :lexical t
(use-package files
  :init
  (setq auto-mode-case-fold nil
        enable-local-variables :all
        save-silently t
        ;; large-file-warning-threshold nil
        confirm-kill-processes nil
        find-file-suppress-same-file-warnings t
        find-file-visit-truename t)

  ;; ISSUE https://github.com/emacsorphanage/osx-trash/issues/5#issuecomment-882759527
  (setq delete-by-moving-to-trash t)
  (when sys/macp
    (setq trash-directory "~/.Trash"))

  ;; SEE https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/
  (defun my/auto-create-missing-dirs ()
    (let ((target-dir (file-name-directory buffer-file-name)))
      (unless (file-exists-p target-dir)
        (make-directory target-dir t))))
  (add-to-list 'find-file-not-found-functions #'my/auto-create-missing-dirs)

  (setq make-backup-files nil
        create-lockfiles nil)

  ;; auto-save
  (setq auto-save-default nil
        auto-save-visited-interval 10)
  (setq auto-save-visited-predicate
        (lambda () (and (buffer-modified-p) (not buffer-read-only))))
  (add-hook 'after-init-hook #'auto-save-visited-mode))
#+end_src

*** saveplace

#+begin_src emacs-lisp :lexical t
(use-package saveplace
  :hook (after-init-hook . save-place-mode)
  :init (setq save-place-limit nil))
#+end_src

*** recentf

#+begin_src emacs-lisp :lexical t
(use-package recentf
  :hook (after-init-hook . recentf-mode)
  :init
  (setq recentf-max-saved-items nil
        recentf-auto-cleanup 15
        recentf-exclude
        '("\\.?cache" "-autoloads\\.el\\'" ".cask" "url" "COMMIT_EDITMSG\\'"
          "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
          "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/" "/.Trash/"
          "^/tmp/" "^/private/tmp/" "^/var/folders/.+$" "/share/emacs/.+$" "\\.git/.+$"
          "bookmarks"))

  (defun recentf-prune ()
    "Delete all recentf records which match selected DIRS."
    (interactive)
    (let* ((vertico-sort-function nil)
           (parent-dirs (let (counts)
                          (dolist (path recentf-list)
                            (cl-incf (alist-get
                                      (abbreviate-file-name
                                       (file-name-parent-directory path))
                                      counts 0 nil 'equal)))
                          (mapcar #'car (seq-sort-by #'cdr #'> counts)))))
      (when-let* ((to-prune (completing-read-multiple
                             (format-prompt "Prune recent directories" nil) parent-dirs)))
        (setq recentf-list
              (seq-remove (lambda (file)
                            (seq-some (lambda (pre)
                                        (string-prefix-p pre file))
                                      to-prune))
                          recentf-list)))))

  :config
  ;; auto-cleanup in save/load
  (advice-add 'recentf-save-list :before #'recentf-cleanup)
  (advice-add 'recentf-load-list :after #'recentf-cleanup)

  ;; silent message
  (mapc (lambda (cmd)
          (advice-add cmd :around #'ad/silent-message))
        '(recentf-load-list
          recentf-save-list
          recentf-cleanup)))
#+end_src

*** savehist

#+begin_src emacs-lisp :lexical t
(use-package savehist
  :hook (after-init-hook . savehist-mode)
  :init
  (setq savehist-autosave-interval 300
        savehist-additional-variables
        '(mark-ring
          global-mark-ring
          search-ring
          regexp-search-ring
          extended-command-history)))
#+end_src

*** minibuffer                                                      :minibuffer:

#+begin_src emacs-lisp :lexical t
(use-package minibuffer
  :init
  (setq enable-recursive-minibuffers t)
  (setq completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion)))))

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

*** subword

#+begin_src emacs-lisp :lexical t
(use-package subword
  :hook ((prog-mode-hook . subword-mode)
         (minibuffer-setup-hook . subword-mode)))
#+end_src

*** delsel

#+begin_src emacs-lisp :lexical t
(use-package delsel
  :hook (after-init-hook . delete-selection-mode))
#+end_src

*** whitespace

#+begin_src emacs-lisp :lexical t
(use-package whitespace
  :init
  (setq whitespace-style '(face empty trailing))
  (face-spec-set 'whitespace-empty
                 '((((background light))
                    :background "#FF6C6B")
                   (t
                    :background "#FF6C6B"))))
#+end_src

*** newcomment

#+begin_src emacs-lisp :lexical t
(use-package newcomment
  :bind ([remap comment-dwim] . newcomment-toggle)
  :init
  (setq comment-empty-lines t)
  :config
  (defun newcomment-toggle (n)
    "Toggle the comments."
    (interactive "*p")
    (if (or (use-region-p)
            (save-excursion
              (beginning-of-line)
              (looking-at "\\s-*$")))
        (call-interactively 'comment-dwim)
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range))))))
#+end_src

*** indent

#+begin_src emacs-lisp :lexical t
(use-package indent-aux
  :hook (after-init-hook . kill-ring-deindent-mode))
#+end_src

*** jit-lock

#+begin_src emacs-lisp :lexical t
(use-package jit-lock
  :init
  (setq jit-lock-defer-time 0
        jit-lock-stealth-time 16))
#+end_src

*** face-remap

#+begin_src emacs-lisp :lexical t
(use-package face-remap
  :init
  (defun my/text-scale-reset ()
    "Reset the font size of default face to origin value."
    (interactive)
    (text-scale-increase 0)))
#+end_src

*** isearch

#+begin_src emacs-lisp :lexical t
(use-package isearch
  :init
  (setq isearch-lazy-count t))
#+end_src

*** crm

#+begin_src emacs-lisp :lexical t
(use-package crm
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  (defun ad/crm-indicator (args)
    "Set indicater ARGS for multiple read."
    (cons (concat "[*] " (car args)) (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'ad/crm-indicator)

  ;; TODO bind to C-t to select all filtered items at once
  (defun crm-complete-all ()))

;; Don't ask me when kill process buffer
(setq kill-buffer-query-functions
      (remq 'process-kill-buffer-query-function
            kill-buffer-query-functions))

(if (get-buffer "*scratch*")
    (setq default-directory "~/"))
#+end_src

*** autorevert

#+begin_src emacs-lisp :lexical t
(use-package autorevert
  :hook (after-init-hook . global-auto-revert-mode)
  :init
  (setq auto-revert-interval 3
        auto-revert-use-notify t
        auto-revert-verbose nil))
#+end_src

*** compile

#+begin_src emacs-lisp :lexical t
(use-package compile
  :config
  (defun compilation-first-error ()
    "Move point to the first error in the compilation buffer."
    (interactive)
    (compilation-next-error 1 nil (point-min)))

  (defun compilation-last-error ()
    "Move point to the last error in the compilation buffer."
    (interactive)
    (compilation-next-error (- 1) nil (point-max)))

  (defun ad/compilation-previous-file (n)
    "Move point at first error when jumping to previous files."
    (interactive "p")
    (compilation-next-file (- n))
    (condition-case nil
        (progn
          (compilation-next-file (- 1))
          (compilation-next-file 1))
      (error
       (compilation-first-error))))
  (advice-add 'compilation-previous-file :override #'ad/compilation-previous-file)

  )

(use-package executable
  :init
  (setq executable-prefix-env t))
#+end_src

*** eldoc

#+begin_src emacs-lisp :lexical t
(use-package eldoc
  :init
  (setq eldoc-idle-delay 0.3))
#+end_src

*** xwidget

#+begin_src emacs-lisp :lexical t
(use-package xwidget
  :autoload xwidget-webkit-current-session
  :hook (xwidget-webkit-mode-hook . xwidget-setup)
  :init
  (defun xwidget-setup ()
    "docstring"
    (goto-address-mode -1)
    (setq-local header-line-format nil)))
#+end_src

*** copyright

#+begin_src emacs-lisp :lexical t
(use-package copyright
  :init
  (setq copyright-year-ranges t
        copyright-query nil))
#+end_src

*** llama

#+begin_src emacs-lisp :lexical t
(use-package llama
  :config (global-llama-fontify-mode))
#+end_src

*** dash

#+begin_src emacs-lisp :lexical t
(use-package dash
  :hook (after-init-hook . global-dash-fontify-mode)
  :init
  (with-eval-after-load 'info-look
    (dash-register-info-lookup)))
#+end_src

*** nerd-icons

install icons: ~brew install font-symbols-only-nerd-font~

#+begin_src emacs-lisp :lexical t
(use-package nerd-icons
  :init
  (setq nerd-icons-font-family "Symbols Nerd Font Mono"))

(use-package nerd-icons-completion
  :hook (after-init-hook . nerd-icons-completion-mode)
  :init
  (setq nerd-icons-completion-icon-size 0.8)
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

(use-package nerd-icons-ibuffer
  :hook (ibuffer-mode-hook . nerd-icons-ibuffer-mode)
  :init
  (setq nerd-icons-ibuffer-icon-size 0.8)
  (setq nerd-icons-ibuffer-formats
        '((mark " " (icon 2 2)
                " " (name 20 20 :left :elide)
                " " modified read-only locked
                " " (size-h 7 -1 :right)
                " " (mode+ 16 16 :left :elide)
                " " filename-and-process+)
          (mark " " name))))
#+end_src

*** duplexer

#+begin_src emacs-lisp :lexical t
(use-package duplexer
  :hook (after-init-hook . duplexer-mode)
  :config
  (setq duplexer-quiet t)
  (setq duplexer-groups
        '(;; built-in
          (no-hl-line . ((hl-line-mode -1) (global-hl-line-mode -1)))
          (read-only  . ((read-only-mode 1)))
          (no-cursor  . ((blink-cursor-mode -1)))
          ;; third-party
          (no-margin  . ((diff-hl-margin-local-mode -1) (binky-margin-local-mode -1)))
          (no-paren   . ((highlight-parentheses-mode -1)))
          (temp-motion . ((my/meow-temp-motion 1)))))

  (setq duplexer-alist
        '((olivetti-mode . (no-margin no-hl-line (focus-mode 1)))
          (redacted-mode . (no-margin no-hl-line no-paren no-cursor read-only))
          (smerge-mode   . (no-margin no-paren (save-place-local-mode -1)))))

  (appendq! duplexer-fallback-alist '((my/meow-temp-motion . meow--temp-state-before))))
#+end_src

*** meow

#+begin_src emacs-lisp :lexical t
;;; TODO write things with treesit api
(use-package meow
  :demand t
  :hook (vterm-mode-hook . meow-mode)
  :init
  ;; HACK to keep consistent with old behaviors
  (setq meow-keypad-leader-dispatch "C-c")

  (defun meow-setup ()
    (meow-normal-define-key
     ;; argument
     '("-" . negative-argument)
     '("q" . meow-quit)

     ;; jump
     '("h" . meow-left)
     '("j" . meow-next)
     '("k" . meow-prev)
     '("l" . meow-right)
     '("b" . meow-back-word)
     '("B" . meow-back-symbol)
     '("e" . meow-next-word)
     '("E" . meow-next-symbol)
     '("f" . meow-find)
     '("t" . meow-till)
     '("z" . meow-goto-line)

     ;; edit
     '("i" . meow-insert)
     '("I" . meow-open-above)
     '("a" . meow-append)
     '("A" . meow-open-below)
     '("c" . meow-change)
     '("C" . meow-change-save)
     '("d" . meow-delete)
     '("D" . meow-backward-delete)
     '("u" . meow-undo)
     '("U" . meow-redo)
     ;; '("U" . meow-undo-in-selection)

     ;; kill-region (cut)
     '("x" . meow-kill)
     '("X" . meow-kill-append)
     ;; kill-ring-save (copy)
     '("y" . meow-save)
     '("Y" . meow-save-append)
     ;; yank (paste)
     '("p" . meow-yank)
     '("P" . meow-yank-pop)
     ;; replace
     '("r" . meow-replace)
     '("R" . meow-replace-save)

     ;; selection
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '(";" . meow-reverse)

     '("H" . meow-left-expand)
     '("J" . meow-next-expand)
     '("K" . meow-prev-expand)
     '("L" . meow-right-expand)
     '("v" . meow-line)
     '("V" . meow-line-expand)
     '("o" . meow-block)
     '("O" . meow-to-block)
     '("T" . meow-join)

     '("g" . meow-cancel-selection)
     '("s" . meow-pop-selection)

     ;; grab
     '("G" . meow-grab)
     '("F" . meow-sync-grab)
     '("S" . meow-swap-grab)
     '("Q" . meow-pop-grab)

     ;; search
     '("n" . meow-search)
     '("N" . meow-visit)
     '("w" . meow-mark-word)
     '("W" . meow-mark-symbol)

     ;; macro
     '("M" . kmacro-start-macro)
     '("m" . meow-end-or-call-kmacro)
     ;; BUG performance issue
     ;; '("Z" . meow-kmacro-lines)
     '("Z" . apply-macro-to-region-lines)

     ;; thing
     '("," . meow-inner-of-thing)
     '("." . meow-bounds-of-thing)
     '("<" . meow-beginning-of-thing)
     '(">" . meow-end-of-thing)

     ;; self-defined
     '("/" . isearch-forward-regexp)
     '("<escape>" . ignore)
     '("'" . binky-binky)
     '("\"" . my/winconf-switch))

    (meow-motion-overwrite-define-key
     '("C-o" . meow-temp-normal)
     '("<escape>" . ignore)
     '("'" . binky-binky)
     '("\"" . my/winconf-switch))

    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     ;; Use SPC (0-9) for digit arguments.
     '("1" . meow-digit-argument)
     '("2" . meow-digit-argument)
     '("3" . meow-digit-argument)
     '("4" . meow-digit-argument)
     '("5" . meow-digit-argument)
     '("6" . meow-digit-argument)
     '("7" . meow-digit-argument)
     '("8" . meow-digit-argument)
     '("9" . meow-digit-argument)
     '("0" . meow-digit-argument)
     '("/" . meow-keypad-describe-key)
     '("?" . meow-cheatsheet)))

  (defvar-local meow--temp-state-before nil)
  (defun my/meow-temp-motion (&optional arg)
    "Switch between meow-motion-mode and meow-normal-mode automatically."
    (interactive "p")
    (when (region-active-p)
      (meow--cancel-selection))
    (if (< arg 0)
        (progn
          (meow--switch-state meow--temp-state-before)
          (setq-local meow--temp-state-before nil))
      (setq-local meow--temp-state-before (meow--current-state))
      (meow--switch-state 'motion)))

  ;; wrapper of meow-redo
  (defvar meow--kbd-undo-redo "C-?"
    "KBD macro for command `undo-redo'.")
  (defun meow-redo ()
    "Cancel current selection then redo."
    (interactive)
    (when (region-active-p)
      (meow--cancel-selection))
    (meow--execute-kbd-macro meow--kbd-undo-redo))

  :config

  (meow-define-keys 'insert
    '("C-j" . meow-open-below)
    '("C-k" . meow-open-above))

  (prependq! meow-mode-state-list
             '((diff-mode . motion)
               (inferior-emacs-lisp-mode . insert)
               (inferior-python-mode . insert)
               (nodejs-repl-mode . insert)
               (quickrun--mode . motion)
               (vterm-mode . insert)
               (term-mode . motion)
               (eshell-mode . insert)
               (lsp-bridge-ref-mode . motion)
               (treesit--explorer-tree-mode . normal)))

  (setq meow-expand-hint-remove-delay 3.0)

  (setq meow-replace-state-name-list
        '((normal . "<N>")
          (motion . "<M>")
          (keypad . "<K>")
          (insert . "<I>")
          (beacon . "<B>")))

  ;; customize thing

  (setq meow-display-thing-help t)
  (setq meow-char-thing-table
        '((?r . round)
          (?s . square)
          (?c . curly)
          (?a . angle)
          (?g . string)
          (?e . symbol)
          (?d . defun)
          (?l . line)
          (?p . paragraph)
          (?b . buffer)
          (?t . tag)
          (?u . url)
          (?w . window)
          (?m . email)))

  (meow-thing-register 'url 'url 'url)
  (meow-thing-register 'email 'email 'email)
  (meow-thing-register 'angle
                       '(pair ("<") (">"))
                       '(pair ("<") (">")))

  ;;; thing for tag
  ;; TODO write for js-jsx-mode and tsx-ts-mode
  ;; (defun jtsx-jsx-element-pos ()
  ;;   "Retun list fo positions of pair tag of current element in `jtsx'."
  ;;   (when-let* (((jtsx-jsx-context-p))
  ;;               (node (jtsx-enclosing-jsx-element-at-point t))
  ;;               (open (treesit-node-child-by-field-name node "open_tag"))
  ;;               (close (treesit-node-child-by-field-name node "close_tag")))
  ;;     (list (treesit-node-start open)
  ;;           (treesit-node-end open)
  ;;           (treesit-node-start close)
  ;;           (treesit-node-end close))))

  (defun web-mode-element-pos ()
    "Retun list fo positions of pair tag of current element in `web-mode'."
    (when-let* ((ele-begin (web-mode-element-beginning-position))
                (ele-end (web-mode-element-end-position)))
      (list ele-begin
            (1+ (web-mode-tag-end-position ele-begin))
            (web-mode-tag-beginning-position ele-end)
            (1+ ele-end))))

  (defun meow--inner-of-tag ()
    (-let [(_ beg end _)
           (pcase major-mode
             ;; ((or 'jtsx-jsx-mode 'jtsx-tsx-mode)
             ;;  (jtsx-jsx-element-pos))
             ('web-mode (web-mode-element-pos))
             (_ nil))]
      (and beg end (cons beg end))))

  (defun meow--bounds-of-tag ()
    (-let [(beg _ _ end)
           (pcase major-mode
             ;; ((or 'jtsx-jsx-mode 'jtsx-tsx-mode)
             ;;  (jtsx-jsx-element-pos))
             ('web-mode (web-mode-element-pos))
             (_ nil))]
      (and beg end (cons beg end))))

  (meow-thing-register 'tag #'meow--inner-of-tag #'meow--bounds-of-tag)

  (meow-setup)
  (meow-global-mode 1)

  (with-eval-after-load 'consult
    (setq meow-goto-line-function #'consult-goto-line))

  ;; HACK disable colorful-mode in meow-grab
  (with-eval-after-load 'colorful-mode
    (defun av/colorful-toggle-on-meow-grab ()
      (when (bound-and-true-p colorful-mode)
        (when (secondary-selection-exist-p)
          (save-excursion
            (font-lock-fontify-region (overlay-start mouse-secondary-overlay)
                                      (overlay-end mouse-secondary-overlay))))
        (when (region-active-p)
          (dolist (ov (overlays-in (region-beginning) (region-end)))
            (when (overlay-get ov 'colorful--overlay)
              (colorful--delete-overlay ov))))))
    (advice-add 'meow-grab :before #'av/colorful-toggle-on-meow-grab)))
#+end_src

*** sis

switch input methods atuomatically with modal edit, ~brew tap laishulu/macism~

#+begin_src emacs-lisp :lexical t
(use-package sis
  :init
  (defun my/meow-reset-sis (&rest _)
    "Reset english input when not in meow-insert-state."
    (unless meow-insert-mode
      (sis-set-english)))

  ;; Reset when switchshi to non-insert meow-state
  (add-hook 'meow-insert-exit-hook #'sis-set-english)
  ;; Reset when refocus in frame
  (add-function :after after-focus-change-function #'my/meow-reset-sis)
  ;; Reset when change window
  (add-hook 'window-selection-change-functions #'my/meow-reset-sis))
#+end_src

*** dired

#+begin_src emacs-lisp :lexical t
(use-package dired
  :hook (dired-mode-hook . dired-mode-setup)
  :bind
  (:map dired-mode-map
   ("C-c C-p" . wdired-change-to-wdired-mode)
   ;; ("C-c C-z f" . browse-url-of-file)
   ("{" . dired-omit-mode)
   ("}" . dired-hide-details-mode))
  :init
  (setq dired-free-space nil
        dired-kill-when-opening-new-dired-buffer t
        dired-recursive-deletes 'always
        dired-recursive-copies 'always)
  (setq dired-dwim-target t)
  (setq dired-movement-style 'cycle)

  (setq dired-no-confirm t
        dired-clean-up-buffers-too t
        dired-clean-confirm-killing-deleted-buffers nil)

  (setq delete-by-moving-to-trash t)

  ;; Use GNU ls as `gls' from `coreutils' if available.
  (when (executable-find "gls")
    (setq dired-use-ls-dired t)
    (setq insert-directory-program "gls")
    ;; do not include any sort options
    (setq dired-listing-switches "-alh --group-directories-first"))

  ;; SEE http://www.nextpoint.se/?p=808
  (defun dired-mark-empty-directories (&optional arg)
    "Mark empty directories.
A prefix argument means to unmark them instead."
    (interactive "P")
    (let ((dired-marker-char (if arg ?\s dired-marker-char)))
      (dired-mark-if
       (when-let* ((dir (dired-get-filename t t)))
         (directory-is-empty-p dir))
       "empty directory")))

  (defun dired-mode-setup ()
    "Dired mode setup."
    (dired-omit-mode)
    (dired-hide-details-mode)
    (diredfl-mode))

  :config

  ;; SEE https://stackoverflow.com/a/38594423 try to define function use defalias
  ;; more sort command
  (defmacro define-dired--sort (sort-by)
    "Define sorting command in dired with SORT-BY and REVERSER."
    (let* ((func-name (intern (concat "dired-sort-by-" sort-by)))
           (func-name-r (intern (concat "dired-sort-by-" sort-by "-reverse")))
           (docstring sort-by)
           (docstring-r (concat sort-by " reversely"))
           (switch (concat (pcase sort-by
                             ("name" "")
                             ((or "size" "version" "extension" "width")
                              (concat "--sort=" sort-by))
                             ((or "mtime" "atime" "ctime" "birth")
                              (concat "--sort=time --time=" sort-by)))))
           (switch-r (concat switch " --reverse"))
           (key (substring sort-by 0 1))
           (key-r (upcase key)))
      `(progn
         (defun ,func-name ()
           ,(concat (format "Sorting files in dired by %s." docstring))
           (declare (modes dired-mode))
           (interactive)
           (dired-sort-other ,(concat dired-listing-switches " " switch)))
         (keymap-set dired-mode-map ,(concat "s " key) #',func-name)
         (defun ,func-name-r ()
           ,(concat (format "Sorting files in dired by %s." docstring-r))
           (declare (modes dired-mode))
           (interactive)
           (dired-sort-other ,(concat dired-listing-switches " " switch-r)))
         (keymap-set dired-mode-map ,(concat "s " key-r) #',func-name-r))))

  ;; unbind key s to set as prefix
  (keymap-unset dired-mode-map "s" t)
  (cl-macrolet ((d-d-l (&rest names)
                  `(progn ,@(cl-loop for n in names
                                     collect `(define-dired--sort ,n)))))
    (d-d-l "name" "size" "version" "extension" "width"
           "mtime" "atime" "ctime" "birth")))

(use-package dired-aux
  :bind
  (:map dired-mode-map
   ("E" . dired-create-empty-file))
  :init
  (setq dired-create-destination-dirs 'always
        dired-create-destination-dirs-on-trailing-dirsep t
        dired-compress-directory-default-suffix t
        dired-vc-rename-file t
        dired-backup-overwrite t
        dired-do-revert-buffer t
        dired-isearch-filenames t)

  (defun my/create-empty-file-multi ()
    "Create multi empty files under directory."
    (interactive)
    (let ((split-string-default-separators ","))
      (if-let* ((files
                 (or (dired-get-marked-files)
                     (->> (read-string "Input new files names(',' as seperator): ")
                          (split-string)
                          (-map #'string-trim)
                          (-remove #'string-empty-p)))))
          (--each files
            (let* ((expanded (expand-file-name it)))
              (if (file-exists-p expanded)
                  (error "Cannot create file %s: file exists" expanded))
              (make-empty-file file 'parents)))
        (message "No files confirmed, operaton cancel.")))))

(use-package dired-x
  :config
  (setq dired-omit-files (concat dired-omit-files "\\|^\\..*$")))

(use-package diredfl
  :config
  (set-face-attribute 'diredfl-dir-name nil :bold t))
#+end_src

*** dirvish

#+begin_src emacs-lisp :lexical t
(use-package dirvish
  :hook (after-init-hook . dirvish-override-dired-mode)
  :bind
  (("C-x d" . dirvish)
   :map dired-mode-map
   ("["   . dirvish-layout-switch)
   ("]"   . dirvish-layout-toggle)
   ("TAB" . dirvish-toggle-subtree-anywhere))
  :init
  (setq dirvish-attributes
        '(subtree-state nerd-icons collapse file-size)
        dirvish-use-mode-line nil
        dirvish-use-header-line nil
        dirvish-preview-dispatchers nil)

  (defun dirvish-toggle-subtree-anywhere ()
    "Toggle current directory subtree or parent directory."
    (interactive)
    (let ((dir-p (file-directory-p (dired-get-filename))))
      (if (and (not dir-p)
               (equal 0 (dirvish-subtree--depth)))
          (dired-up-directory)
        (and (not dir-p) (dirvish-subtree-up))
        (dirvish-subtree-toggle))))

  ;; TODO fix dired-goto-file if subtree is on.

  :config

  ;; setup layout
  (setq dirvish-default-layout '(0 0 0.75))
  (setq dirvish-layout-recipes
        `((1 0.11 0.55)
          ;; HACK hide preview window as small as possible to imitate full-screen dired
          (0 0 0.02)
          ,dirvish-default-layout))

  (use-package dirvish-subtree
    :init
    (setq dirvish-subtree-listing-switches "-A"
          dirvish-subtree-always-show-state t
          dirvish-subtree-prefix " "))

  (use-package dirvish-icons
    :init
    (setq dirvish-nerd-icons-height 0.8)))
#+end_src

*** vertico                                                         :minibuffer:

#+begin_src emacs-lisp :lexical t
(use-package vertico
  :hook (after-init-hook . vertico-mode)
  :init
  (setq vertico-cycle t
        vertico-count 20
        resize-mini-windows t
        vertico-sort-function 'vertico-sort-history-length-alpha)
  :bind
  (("C-c C-r" . vertico-repeat)
   (:map vertico-map
    ("RET" . vertico-directory-enter)
    ("DEL" . vertico-directory-delete-char)))

  :config
  (require 'vertico-sort)

  (require 'vertico-multiform)
  (add-to-list 'vertico-multiform-categories
               '(jinx grid (vertico-grid-annotate . 20)))
  (vertico-multiform-mode 1)

  ;; SEE https://github.com/minad/vertico/wiki#prefix-current-candidate-with-arrow
  (defun ad/vertico-customize-candidate (orig cand prefix suffix index _start)
    (concat (if (= vertico--index index)
                (propertize "> " 'face 'font-lock-warning-face)
              "  ")
            (funcall orig cand prefix suffix index _start)))
  (advice-add 'vertico--format-candidate :around #'ad/vertico-customize-candidate)

  ;; SEE https://github.com/minad/vertico/wiki#left-truncate-recentf-filename-candidates-eg-for-consult-buffer
  (defun my/vertico-truncate-candidates (args)
    (if-let* ((arg (car args))
              (type (get-text-property 0 'multi-category arg))
              ((eq (car-safe type) 'file))
              (w (max 30 (- (window-width) 38)))
              (l (length arg))
              ((> l w)))
        (setcar args (concat ".." (truncate-string-to-width arg l (- l w)))))
    args)
  (advice-add #'vertico--format-candidate :filter-args #'my/vertico-truncate-candidates)
  )
#+end_src

*** marginalia

#+begin_src emacs-lisp :lexical t

(use-package marginalia
  :hook (vertico-mode-hook . marginalia-mode)
  :config
  (setq marginalia-align 'right
        marginalia-align-offset -1)
  (appendq! marginalia-prompt-categories
            '(("\\<directory\\|directories\\>" . file)))
  )
#+end_src

*** orderless

#+begin_src emacs-lisp :lexical t
;; SEE https://github.com/minad/consult/wiki#minads-orderless-configuration
(use-package orderless
  :demand t
  :after vertico
  :config
  (setq completion-styles '(orderless basic))
  (setq orderless-component-separator #'orderless-escapable-split-on-space)
  (setq completion-category-defaults nil)

  (orderless-define-completion-style
      my/orderless-mix
    (orderless-matching-styles '(orderless-initialism
                                 orderless-literal
                                 orderless-regexp)))
  (setq completion-category-overrides
        '((file     (styles partial-completion))
          (command  (styles my/orderless-mix))
          (variable (styles my/orderless-mix))
          (symbol   (styles my/orderless-mix))))

  ;; (with-eval-after-load 'consult
  ;;   (defun consult--orderless-regexp-compiler (input type &rest _config)
  ;;     (setq input (cdr (orderless-compile input)))
  ;;     (cons
  ;;      (mapcar (lambda (r) (consult--convert-regexp r type)) input)
  ;;      (lambda (str) (orderless--highlight input t str))))
  ;;   (setq consult--regexp-compiler #'consult--orderless-regexp-compiler))

  (with-eval-after-load 'pinyinlib
    (defun ad/orderless-regexp-pinyin (args)
      "Patch `orderless-regexp' with pinyin surpport"
      (setf (car args) (pinyinlib-build-regexp-string (car args)))
      args)
    (advice-add 'orderless-regexp :filter-args #'ad/orderless-regexp-pinyin)))
#+end_src

*** consult                                                         :minibuffer:

#+begin_src emacs-lisp :lexical t
(use-package consult
  :after vertico
  :bind
  (;;ctl-x-map
   ("C-x b"   . consult-buffer)
   ("C-x 4 b" . consult-buffer-other-window)
   ("C-x C-d" . consult-dir)
   ("C-x M-:" . consult-complex-command)
   ("C-x r b" . consult-bookmark)
   ;;goto-map
   ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
   ("M-g M-g" . consult-goto-line)
   ("M-g i" . consult-imenu)
   ("M-g I" . consult-imenu-multi)
   ("M-g t" . consult-todo)
   ("M-g e" . consult-compile-error)
   ;;search-map
   ("M-s d" . consult-find)   ;; Alternative: consult-fd
   ("M-s r" . consult-ripgrep)
   ("M-s l" . consult-line)
   ("M-s L" . consult-line-multi)
   ("M-s k" . consult-keep-lines)
   ("M-s e" . consult-isearch-history)
   ("M-s u" . consult-focus-lines)
   ("M-y" . consult-yank-pop)
   ;;mode-specific-map
   ("C-c M-x" . consult-mode-command)
   :map isearch-mode-map
   ("M-e"   . consult-isearch-history)
   ("M-s e" . consult-isearch-history) ;; orig. isearch-edit-string
   ("M-s l" . consult-line) ;; needed by consult-line to detect isearch
   ("M-s L" . consult-line-multi) ;; needed by consult-line to detect isearch
   )

  :init
  (setq consult-async-min-input 1)
  (setq consult-async-split-style 'semicolon)
  (setq consult-line-start-from-top t)

  :config
  (setq-default completion-in-region-function #'consult-completion-in-region)
  (setq consult-narrow-key "<")

  ;; -------------------------- Source ------------------------------

  ;; NOTE
  ;; 1. hidden: add regexp in `consult-buffer-filter' or filter with :predicate
  ;;    in `consult--source-buffer'
  ;; 2. extract: set :filter nil and :predicate in consult--source-*

  (appendq! consult-buffer-filter '("\\`\\*.*\\*\\'"
                                    "\\`.*\\.el\\.gz\\'"
                                    "\\`magit[:-].*\\'"
                                    "\\`COMMIT_EDITMSG\\'"
                                    "\\`.+~.+~\\'"
                                    "\\`\\*vterm\\*.*\\'"))

  ;; enable hidden buffer preview
  (consult-customize consult--source-hidden-buffer :state #'consult--buffer-state)

  ;; filter `consult--source-buffer'
  (consult-customize
   consult--source-buffer
   :items
   (lambda ()
     (consult--buffer-query
      :sort 'visibility
      :as #'buffer-name
      :predicate
      (lambda (buffer)
        (let ((mode (buffer-local-value 'major-mode buffer)))
          (not (eq mode 'dired-mode)))))))

  ;; Dired-source
  (defvar consult--source-dired
    `(:name     "Dired"
      :narrow   ?d
      :hidden   t
      :category buffer
      :face     dired-header
      :state    ,#'consult--buffer-state
      :items
      ,(lambda ()
         (consult--buffer-query
          :mode 'dired-mode
          :filter nil
          :sort 'visibility
          :as #'buffer-name)))
    "Dired buffer candidate source for `consult-buffer'.")
  (add-to-list 'consult-buffer-sources 'consult--source-dired)

  ;; atomic-chrome buffers
  (defvar consult--source-atomic
    `(:name     "Atomic"
      :narrow   ?a
      :hidden   t
      :category buffer
      :face     dired-warning
      :state    ,#'consult--buffer-state
      :items
      ,(lambda ()
         (consult--buffer-query
          :sort 'visibility
          :as #'buffer-name
          :filter nil
          :predicate
          (lambda (buffer)
            (with-current-buffer buffer
              (bound-and-true-p atomic-chrome-edit-mode))))))
    "Atomic buffer candidate source for `consult-buffer'.")
  (add-to-list 'consult-buffer-sources 'consult--source-atomic)

  ;; xwidget buffers
  (defvar consult--source-xwidget
    `(:name     "Xwidget"
      :narrow   ?x
      :hidden   t
      :category buffer
      :face     dired-warning
      :state    ,#'consult--buffer-state
      :items
      ,(lambda ()
         (consult--buffer-query
          :mode 'xwidget-webkit-mode
          :sort 'visibility
          :as #'buffer-name
          :filter nil)))
    "Xwidget buffer candidate source for `consult-buffer'.")
  (add-to-list 'consult-buffer-sources 'consult--source-xwidget)

  ;; Blob-source
  (defvar consult--source-blob
    `(:name     "Blob"
      :narrow   ?g
      :hidden   t
      :category buffer
      :face     transient-pink
      :state    ,#'consult--buffer-state
      :items
      ,(lambda ()
         (consult--buffer-query
          :sort 'visibility
          :as #'buffer-name
          :filter nil
          :predicate
          (lambda (buffer)
            (string-match-p "\\`.+~.+~\\'" (buffer-name buffer))))))
    "Blob buffer candidate source for `consult-buffer'.")
  (add-to-list 'consult-buffer-sources 'consult--source-blob)

  ;; Org-source
  (autoload 'org-buffer-list "org")
  (defvar consult--source-org
    `(:name     "Org"
      :narrow   ?o
      :hidden   t
      :category buffer
      :face     org-headline-todo
      :state    ,#'consult--buffer-state
      :items
      ,(lambda ()
         (consult--buffer-query
          :mode 'org-mode
          :filter nil
          :sort 'visibility
          :as #'buffer-name)))
    "Org buffer candidate source for `consult-buffer'.")
  (add-to-list 'consult-buffer-sources 'consult--source-org)

  ;; ------------------------- Preview ------------------------------

  (setq consult-preview-allowed-hooks '(global-font-lock-mode-check-buffers))

  ;; disable preview
  (consult-customize
   consult-recent-file consult-bookmark consult--source-recent-file
   consult--source-project-recent-file consult--source-bookmark
   consult-ripgrep consult-git-grep consult-grep
   :preview-key nil)

  ;; -------------------------- Extra -------------------------------

  (require 'consult-xref)
  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)
  (require 'consult-register)
  ;; Optionally configure the register formatting.
  (setq register-preview-delay 0
        register-preview-function #'consult-register-format)

  (require 'consult-imenu)
  (setq consult-imenu-config
        '((emacs-lisp-mode
           :toplevel "Functions"
           :types ((?f "Functions"   font-lock-function-name-face)
                   (?y "Types"       font-lock-type-face)
                   (?v "Variables"   font-lock-variable-name-face)
                   (?c "Commands"    font-lock-constant-face)
                   (?u "Customs"     font-lock-string-face)
                   (?a "Faces"       font-lock-type-face)
                   (?l "Leafs"       font-lock-keyword-face)
                   (?m "Macros"      font-lock-function-name-face)
                   (?k "Keys"        font-lock-variable-name-face)
                   (?t "Transients"  font-lock-type-face)))
          (js-mode
           :types ((?c "Classes"    font-lock-type-face)
                   (?f "Functions"  font-lock-function-name-face)
                   (?s "Constants"  font-lock-constant-face)
                   (?m "Methods"    font-lock-string-face)
                   (?p "Properties" font-lock-builtin-face)
                   (?v "Variables"  font-lock-variable-name-face)
                   (?e "Fields"     font-lock-warning-face)))
          (js-ts-mode
           :types ((?c "Class"      font-lock-type-face)
                   (?f "Function"   font-lock-function-name-face)
                   ;; (?s "Constants"  font-lock-constant-face)
                   ;; (?m "Methods"    font-lock-string-face)
                   ;; (?p "Properties" font-lock-builtin-face)
                   ;; (?v "Variables"  font-lock-variable-name-face)
                   ;; (?e "Fields"     font-lock-warning-face)
                   ))
          (python-mode
           :types ((?c "Classes"    font-lock-type-face)
                   (?f "Functions"  font-lock-function-name-face)
                   (?v "Variables"  font-lock-variable-name-face)))
          (sh-mode
           :types ((?f "Functions"  font-lock-function-name-face)
                   (?v "Variables"  font-lock-variable-name-face)))
          (md-ts-mode
           :types ((?1 "H1" md-ts-header-1)
                   (?2 "H2" md-ts-header-2)
                   (?3 "H3" md-ts-header-3)
                   (?4 "H4" md-ts-header-4)
                   (?5 "H5" md-ts-header-5)
                   (?6 "H6" md-ts-header-6)))))

  (use-package consult-dir
    :init
    (setq consult-dir-default-command #'consult-dir-dired)
    :config
    (defvar consult-dir--source-zlua
      `(:name     "Zlua Dir"
        :narrow   ?z
        :category file
        :face     consult-file
        :history  file-name-history
        :enabled  ,(lambda () (getenv "ZLUA_SCRIPT"))
        :items
        ,(lambda ()
           (nreverse (mapcar
                      (lambda (p) (abbreviate-file-name (file-name-as-directory p)))
                      ;; REQUIRE export `ZLUA_SCRIPT' in parent-shell
                      (split-string (shell-command-to-string
                                     "lua $ZLUA_SCRIPT -l | perl -lane 'print $F[1]'")
                                    "\n" t)))))
      "Zlua directory source for `consult-dir'.")
    (add-to-list 'consult-dir-sources 'consult-dir--source-zlua t))

  )
#+end_src

*** embark

#+begin_src emacs-lisp :lexical t
(use-package embark
  :after vertico
  :bind
  (("M-l" . embark-act)
   :map embark-general-map
   ("C-c C-a" . marginalia-cycle)
   :map vertico-map
   ("C-l" . embark-act)
   ("C-c C-o" . embark-export)
   ("C-c C-a" . marginalia-cycle)
   :map embark-expression-map
   ("M" . pp-macroexpand-all-expression)
   :map embark-library-map
   ("o" . find-library-other-window)
   :map embark-identifier-map
   ("d" . lsp-bridge-find-def-other-window))

  :init
  (setq embark-prompter 'embark-keymap-prompter
        embark-mixed-indicator-delay 0.6)

  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))
  (advice-add 'embark-verbose-indicator :override 'embark-which-key-indicator)

  :config

  ;; HACK Open source code of `symbol' in other window
  (dolist (cmd '(embark-find-definition))
    (advice-add cmd :before #'open-in-other-window))

  (use-package embark-consult
    :after embark consult))
#+end_src

*** hideshow

#+begin_src emacs-lisp :lexical t :tangle no
(use-package hideshow
  :hook (prog-mode-hook . hs-mode-setup)
  :init
  (setq hs-isearch-open t
        hs-hide-comments-when-hiding-all t)

  ;; display more information
  (defun display-code-line-counts (ov)
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put ov 'display
                   (propertize
                    (format "...%d"
                            (- (count-lines (overlay-start ov) (overlay-end ov)) 1))
                    'face 'shadow))))
  (setq hs-set-up-overlay #'display-code-line-counts)

  (defun hs-mode-setup ()
    "hs-minor-mode setup."
    (unless (memq major-mode '(vue-ts-mode moonbit-mode))
      (hs-minor-mode 1)))
  )
#+end_src

*** yasnippet

#+begin_src emacs-lisp :lexical t
(use-package yasnippet
  :hook (after-init-hook . yas-global-mode)
  :bind
  (:map yas-keymap
   ([tab] . yas-next-field)
   ("TAB" . yas-next-field))
  :init
  (setq yas-minor-mode-map nil)
  (setq yas-alias-to-yas/prefix-p nil)
  (setq yas-indent-line 'auto)
  (setq yas-new-snippet-default "\
# -*- mode: snippet -*-
# name: ${1:name}
# contributor : ${2:`user-full-name`<`user-mail-address`>}
# key: ${3:key}
# --
$0`(yas-escape-text yas-selected-text)`")

  ;; silent message in start.
  (advice-add #'yas-reload-all :around #'ad/silent-message)

  :config

  ;; enable commit snippets
  (add-hook 'git-commit-mode-hook
            (lambda () (yas-activate-extra-mode 'git-commit-mode)))

  (use-package yasnippet-collection
    :demand t
    :config
    (yasnippet-collection-initialize)))
#+end_src

*** repeat

#+begin_src emacs-lisp :lexical t
(use-package repeat
  :hook (after-init-hook . repeat-mode)
  :init
  (setq repeat-exit-key (kbd "C-g")))

(use-package repeat-help
  :hook (repeat-mode-hook . repeat-help-mode)
  :init
  (setq repeat-help-popup-type 'which-key))

(use-package repeat-fu)
#+end_src

*** mini-echo

#+begin_src emacs-lisp :lexical t
(use-package mini-echo
  :hook (after-init-hook . mini-echo-mode)
  :init
  (setq mode-line-position-column-line-format '("%l:%c,%p"))
  (setq mini-echo-right-padding 2)
  (setq mini-echo-mise-show-always nil)
  (setq mini-echo-persistent-rule
        '(:long ("meow" "shrink-path" "vcs" "buffer-position"
                 "buffer-size" "flymake" "mise" "envrc")
          :short ("meow" "buffer-name" "buffer-position" "flymake")))

  (setq mini-echo-persistent-function #'my/mini-echo-persistent-detect)
  (defun my/mini-echo-persistent-detect ()
    (with-current-buffer (current-buffer)
      (pcase major-mode
        ((guard (and (fboundp 'org-src-edit-buffer-p) (org-src-edit-buffer-p)))
         '(:both ("meow" "org-src" "buffer-position" "buffer-size" "flymake")))
        ((guard (bound-and-true-p atomic-chrome-edit-mode))
         '(:both ("meow" "atomic-chrome" "buffer-name" "buffer-position" "flymake")))
        ((guard (bound-and-true-p magit-blob-mode))
         '(:both ("meow" "magit-blob" "buffer-position" "buffer-size")))
        ((guard (or (memq major-mode '(git-commit-elisp-text-mode git-rebase-mode))
                    (string-match-p "\\`magit-.*-mode\\'" (symbol-name major-mode))))
         '(:both ("meow" "major-mode" "project")))
        ((guard (and (fboundp 'popper-display-control-p)
                     (popper-display-control-p (current-buffer))))
         '(:both ("meow" "popper")))
        ('profiler-report-mode '(:both ("meow" "major-mode" "profiler-report")))
        ('rg-mode '(:both ("meow" "major-mode")))
        ('diff-mode '(:both ("meow" "major-mode")))
        ('ibuffer-mode '(:both ("meow" "major-mode")))
        ('dired-mode '(:both ("meow" "major-mode" "dired")))
        ('helpful-mode '(:both ("meow" "major-mode" "helpful")))
        ('treesit--explorer-tree-mode '(:both ("meow" "major-mode" "treesit-explorer")))
        ('xwidget-webkit-mode '(:both ("meow" "major-mode" "xwidget")))
        (_ nil)))))
#+end_src

*** insecure-lock

#+begin_src emacs-lisp :lexical t
(use-package insecure-lock
  :bind
  ("s-q" . insecure-lock-enter)
  :init
  (setq insecure-lock-require-password nil)
  (setq insecure-lock-mode-hook '(insecure-lock-redact-with-minibuf insecure-lock-posframe))
  (defun insecure-lock-redact-with-minibuf ()
    "`insecure-lock' module that redacts buffers.
No changes in mode-line."
    (unless (require 'redacted nil t) (user-error "Package `redacted' not available"))
    (let ((arg (if insecure-lock-mode 1 -1)))
      (dolist (frame (frame-list))
        ;; NOTE call redacted-mode also in minibuf
        (dolist (window (window-list frame t))
          (with-current-buffer (window-buffer window)
            (redacted-mode arg)))))))
#+end_src

*** page-break-lines

#+begin_src emacs-lisp :lexical t
(use-package page-break-lines
  :hook (after-init-hook . global-page-break-lines-mode)
  :init
  (setq page-break-lines-max-width fill-column))
#+end_src

*** themes

#+begin_src emacs-lisp :lexical t
(use-package doom-themes
  :demand t
  :config
  (load-theme 'doom-tokyo-night t)
  :init
  (advice-add 'load-theme :after #'av/doom-theme-customize)
  (defun av/doom-theme-customize (&rest _)
    (pcase (car custom-enabled-themes)
      ('doom-tokyo-night
       (custom-set-faces
        `(font-lock-constant-face ((t (:foreground ,(doom-color 'red)))))
        `(font-lock-builtin-face ((t (:foreground ,(doom-color 'orange)))))
        `(font-lock-delimiter-face ((t (:foreground ,(doom-color 'base3)))))
        `(font-lock-number-face ((t (:foreground ,(doom-color 'yellow)))))
        `(font-lock-type-face ((t (:foreground ,(doom-color 'yellow) :bold t))))
        `(font-lock-property-name-face ((t (:foreground ,(doom-color 'teal)))))
        `(font-lock-variable-name-face ((t (:foreground ,(doom-color 'dark-cyan)))))
        `(font-lock-escape-face ((t (:foreground ,(doom-color 'magenta) :bold t))))
        ;; `(font-lock-punctuation-face ((t (:foreground ,(doom-color 'red)))))
        ;; `(font-lock-misc-punctuation-face ((t (:foreground ,(doom-color 'red)))))
        `(font-lock-regexp-face ((t (:foreground ,(doom-lighten (doom-color 'green) 0.8)))))
        `(secondary-selection ((t (:background ,(doom-darken (doom-color 'violet) 0.7)))))
        `(link ((t (:foreground ,(doom-color 'dark-cyan) :bold nil))))
        `(hl-line ((t (:background ,(doom-darken (doom-color 'blue) 0.75)))))
        `(line-number ((t (:italic nil))))
        `(line-number-current-line ((t (:italic nil))))
        ;;consult
        '(consult-file         ((t (:inherit font-lock-doc-face))))
        '(consult-imenu-prefix ((t (:inherit font-lock-doc-face :slant italic))))
        ;; vertico
        `(vertico-current ((t (:background ,(doom-darken (doom-color 'blue) 0.7) :extend t))))
        ;;diff-hl
        `(diff-hl-change ((t (:background unspecified
                              :inverse-video nil
                              :italic nil))))
        `(diff-hl-insert ((t (:background unspecified
                              :inverse-video nil
                              :italic nil))))
        `(diff-hl-delete ((t (:background unspecified
                              :inverse-video nil
                              :italic nil))))
        ;; transient
        `(transient-key-exit ((t (:foreground ,(doom-color 'yellow)))))
        `(transient-key-stay ((t (:foreground ,(doom-color 'green)))))
        `(transient-key-return ((t (:foreground ,(doom-color 'violet)))))
        ;; mini-echo
        `(mini-echo-red ((t (:foreground ,(doom-color 'red)))))
        `(mini-echo-green ((t (:foreground ,(doom-color 'green)))))
        `(mini-echo-yellow ((t (:foreground ,(doom-color 'yellow)))))
        `(mini-echo-blue ((t (:foreground ,(doom-color 'blue)))))
        `(mini-echo-magenta ((t (:foreground ,(doom-color 'magenta)))))
        `(mini-echo-cyan ((t (:foreground ,(doom-color 'cyan)))))
        `(mini-echo-gray ((t (:foreground ,(doom-color 'dark-blue)))))
        ;; meow
        `(meow-normal-indicator   ((t (:foreground ,(doom-color 'blue) :bold t))))
        `(meow-insert-indicator   ((t (:foreground ,(doom-color 'green) :bold t))))
        `(meow-motion-indicator   ((t (:foreground ,(doom-color 'red) :bold t))))
        `(meow-keypad-indicator   ((t (:foreground ,(doom-color 'magenta) :bold t))))
        `(meow-beacon-indicator   ((t (:foreground ,(doom-color 'yellow) :bold t))))
        `(meow-search-indicator   ((t (:foreground ,(doom-color 'cyan) :bold t))))
        `(meow-beacon-fake-cursor ((t (:foreground ,(doom-color 'bg)
                                       :background ,(doom-blend 'yellow 'bg 0.7)
                                       :bold t))))
        `(meow-position-highlight-number-1 ((t (:inherit orderless-match-face-1))))
        `(meow-position-highlight-number-2 ((t (:inherit orderless-match-face-2))))
        `(meow-position-highlight-number-3 ((t (:inherit orderless-match-face-3))))
        ;; dirvish
        '(dirvish-hl-line ((t (:inherit hl-line))))
        ;; mini-echo
        `(window-divider ((t (:foreground ,(doom-color 'base0)))))
        ;; magit
        `(magit-blame-dimmed ((t (:foreground ,(doom-color 'bg)))))
        `(magit-blame-margin ((t (:foreground ,(doom-blend 'blue 'fg 0.6)
                                  :background ,(doom-blend 'blue 'bg 0.1)
                                  :bold t))))
        ;; md-ts-mode
        `(md-ts-code-block ((t (:background ,(doom-darken 'base2 0.65)
                                :extend t))))
        `(org-block            ((t (:background ,(doom-blend 'bg 'base3 0.95)))))
        `(org-block-begin-line ((t (:background ,(doom-blend 'bg 'base3 0.95)
                                    :foreground ,(doom-color 'doc-comments)
                                    :extend t))))
        ;; combobulate
        '(combobulate-refactor-highlight-face ((t (:background unspecified))))
        `(combobulate-refactor-label-face ((t (:foreground ,(doom-color 'bg)
                                               :background ,(doom-blend 'cyan 'bg 0.7)
                                               :bold t))))
        `(combobulate-active-indicator-face ((t (:foreground ,(doom-blend 'cyan 'bg 0.7)
                                                 :bold t))))
        ;; web-mode
        `(web-mode-html-tag-bracket-face ((t (:foreground ,(doom-color 'dark-blue)))))
        `(web-mode-html-entity-face ((t (:italic nil :foreground ,(doom-color 'teal)))))
        `(web-mode-current-element-highlight-face
          ((t (:weight bold :background ,(doom-blend 'cyan 'bg 0.15)))))
        `(web-mode-current-column-highlight-face  ((t (:background ,(doom-color 'base4)
                                                       :foreground unspecified))))
        ;; orderless
        `(orderless-match-face-0 ((t (:underline t))))
        `(orderless-match-face-1 ((t (:underline t))))
        `(orderless-match-face-2 ((t (:underline t))))
        `(orderless-match-face-3 ((t (:underline t))))
        ;;rg.el
        `(rg-match-face ((t (:inherit orderless-match-face-2))))
        `(rg-info-face        ((t (:foreground ,(doom-color 'red)))))
        `(rg-filename-face    ((t (:foreground ,(doom-color 'blue) :underline t))))
        `(rg-line-number-face ((t (:foreground ,(doom-color 'yellow)))))
        `(rg-file-tag-face ((t (:foreground ,(doom-color 'magenta)))))
        ;; wgrep
        `(wgrep-face ((t (:foreground ,(doom-color 'yellow)
                          :background unspecified
                          :bold nil))))
        `(wgrep-delete-face ((t (:foreground ,(doom-color 'red)
                                 :background unspecified
                                 :strike-through t))))
        `(rainbow-delimiters-depth-1-face ((t (:foreground ,(doom-color 'blue)))))
        `(rainbow-delimiters-depth-2-face ((t (:foreground ,(doom-color 'yellow)))))
        `(rainbow-delimiters-depth-3-face ((t (:foreground ,(doom-color 'magenta)))))
        `(rainbow-delimiters-depth-4-face ((t (:foreground ,(doom-color 'teal)))))
        `(rainbow-delimiters-depth-5-face ((t (:foreground ,(doom-color 'red)))))
        `(which-key-note-face ((t (:foreground ,(doom-color 'yellow)))))
        ))))
  )
#+end_src

*** hl-todo                                                     :todo:highlight:

#+begin_src emacs-lisp :lexical t
(use-package hl-todo
  :hook (after-init-hook . global-hl-todo-mode)
  :init
  (setq hl-todo-wrap-movement t)
  (setq hl-todo-keyword-faces
        '(("TODO"       . "#73daca")
          ("HACK"       . "#bb9af7")
          ("FIXME"      . "#ff9e64")
          ("WORKAROUND" . "#ff9e64")
          ("SEE"        . "#7aa2f7")
          ("REQUIRE"    . "#7aa2f7")
          ("NOTE"       . "#7aa2f7")
          ("PR"         . "#e0af68")
          ("ISSUE"      . "#e0af68")
          ("DISCUSSION" . "#e0af68")
          ("BUG"        . "#f7768e")
          ("XXX"        . "#f7768e")
          ("WONTFIX"    . "#565f89")
          ("DEPRECATED" . "#565f89"))))
#+end_src

*** colorful-mode                                                    :highlight:

#+begin_src emacs-lisp :lexical t
(use-package colorful-mode
  :hook
  (after-init-hook . global-colorful-mode)
  (colorful-mode-hook . colorful-mode-setup)
  :init
  (setopt css-fontify-colors nil)
  (setopt colorful-use-prefix t
          colorful-only-strings t
          ;; black medium square
          colorful-prefix-string "\u25FC"
          colorful-allow-mouse-clicks nil)
  (setq colorful-extra-color-keyword-functions
        '(colorful-add-hex-colors
          colorful-add-rgb-colors
          (emacs-lisp-mode . colorful-add-color-names)
          ((mhtml-mode mhtml-ts-mode html-ts-mode css-mode css-ts-mode) .
           (colorful-add-css-variables-colors
            colorful-add-rgb-colors
            colorful-add-hsl-colors
            colorful-add-oklab-oklch-colors
            colorful-add-color-names))
          (latex-mode . colorful-add-latex-colors)))

  ;; TODO support tailwindcss
  ;; (defun colorful-add-tailwind-colors ())

  (defun colorful-mode-setup ()
    "colorful-mode setup."
    (when (memq major-mode '(css-mode css-ts-mode sass-mode scss-mode))
      (setq-local colorful-only-strings nil)))

  )
#+end_src

*** rainbow-delimiters

#+begin_src emacs-lisp :lexical t
(use-package rainbow-delimiters
  :hook (prog-mode-hook . rainbow-delimiters-mode)
  :init
  (setq rainbow-delimiters-max-face-count 5))
#+end_src

*** highlight-parentheses

#+begin_src emacs-lisp :lexical t
;; FIXME only show overlays on selected-window
;; window-selection-change-functions
(use-package highlight-parentheses
  :hook
  ((prog-mode-hook helpful-mode-hook) . highlight-parentheses-mode)
  (minibuffer-setup-hook . highlight-parentheses-minibuffer-setup)
  :init
  (setq highlight-parentheses-delay 0.05
        highlight-parentheses-highlight-adjacent t
        highlight-parentheses-colors nil
        highlight-parentheses-attributes '((:inverse-video t :weight bold))))
#+end_src

*** highlight-defined

Syntax highlighting of known Elisp symbols

#+begin_src emacs-lisp :lexical t
(use-package highlight-defined
  :init (setq highlight-defined-face-use-itself t))
#+end_src

***

#+begin_src emacs-lisp :lexical t
(use-package diff-hl
  :hook (after-init-hook . global-diff-hl-mode)
  :init
  (setq diff-hl-draw-borders nil
        diff-hl-ask-before-revert-hunk nil
        diff-hl-show-staged-changes nil
        diff-hl-side 'left)
  :config

  (use-package diff-hl-margin
    :hook (global-diff-hl-mode-hook . diff-hl-margin-mode)
    :init
    ;; SEE https://symbl.cc/en/unicode/blocks/block-elements/
    ;; (char-to-string ?\x258d) => "▍" , ?\x2588 - 258f
    ;; if font is designed for chinese,then use ?\x258f, or use ?\x258d instead.
    (setq diff-hl-margin-symbols-alist
          '((insert  . "\x258f")
            (delete  . "\x258f")
            (change  . "\x258f")
            (unknown . "\x258f")
            (ignored . "\x258f"))))

  (use-package diff-hl-dired
    :hook (dired-mode-hook . diff-hl-dired-mode-unless-remote))

  (use-package diff-hl-flydiff
    :hook (diff-hl-mode-hook . diff-hl-flydiff-mode))

  ;; Integration with magit
  (with-eval-after-load 'magit
    (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
    (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)))
#+end_src

*** indent-bars

#+begin_src emacs-lisp :lexical t
;; SEE https://github.com/jdtsmith/indent-bars.git
;; (use-package indent-bars
;;   :hook (prog-mode-hook . indent-bars-mode)
;;   :init
;;   (setq
;;    indent-bars-pattern "."
;;    indent-bars-width-frac 0.5
;;    indent-bars-pad-frac 0.25
;;    indent-bars-color-by-depth nil
;;    indent-bars-highlight-current-depth '(:face default :blend 0.4)))
#+end_src

*** window

#+begin_src emacs-lisp :lexical t
(use-package window
  :init
  (setq window-min-height 1
        fit-window-to-buffer-horizontally t
        delete-window-choose-selected 'pos)

  (add-to-list 'display-buffer-alist
               '("^\\*Emacs Log\\*"
                 (display-buffer-reuse-window
                  display-buffer-in-side-window)
                 (reusable-frames . visible)
                 (side            . right)
                 (window-width    . 0.25))))
(defvar my/winconf-list nil)
#+end_src

*** toggle-one-window

#+begin_src emacs-lisp :lexical t
;; TODO refactor and update automatically
(defun my/winconf-switch (&optional new)
  (interactive "P")
  (if new
      (let ((len (length my/winconf-list)))
        (cl-pushnew (current-window-configuration)
                    my/winconf-list
                    :test #'window-configuration-equal-p)
        (when (= (- (length my/winconf-list) len) 1)
          (message "Add new layout !")))
    (if my/winconf-list
        (let* ((current (current-window-configuration))
               (len (length my/winconf-list))
               (head (car my/winconf-list))
               (head-p (window-configuration-equal-p current head)))
          (if (not head-p)
              (set-window-configuration head)
            (if (= len 1)
                (message "Already on the only window layout yet.")
              (set-window-configuration (cadr my/winconf-list))
              (setq my/winconf-list (nconc (cdr my/winconf-list) (list head))))))
      (message "No window layout saved yet."))))

(defun toggle-one-window ()
  "Toggle between window layout between multi and one."
  (interactive)
  (if (length= (cl-remove-if #'window-dedicated-p (window-list)) 1)
      (if-let* ((saved (get 'toggle-one-window 'saved)))
          (progn
            (set-window-configuration saved)
            (put 'toggle-one-window 'saved nil))
        (message "No saved window configuration."))
    (put 'toggle-one-window 'saved (current-window-configuration))
    (delete-other-windows)))
#+end_src

*** shackle

#+begin_src emacs-lisp :lexical t
;; SEE https://github.com/seagle0128/.emacs.d/blob/320ae719a1acb84c047e94bb6ee3f33e426f7b47/lisp/init-window.el#L204
(use-package shackle
  :hook (after-init-hook . shackle-mode)
  :init
  (setq shackle-default-rule nil)
  (setq shackle-rules
        '(
          ;; builtin
          (("*Warnings*" "*Messages*") :size 0.3 :align 'below)
          ("\\*[Wo]*Man.*\\*" :regexp t :popup t :select t :size 0.5 :align 'below)
          ;; third-party

          ;; BUG other,no-select
          ;; ("elisp-demos.org" :select nil :other t)

          ("*format-all-errors*" :size 0.3 :align 'below)
          (helpful-mode :other t :select nil)
          (" *Flycheck checkers*" :select t :size 0.3 :align 'below)
          ((flycheck-error-list-mode flymake-diagnostics-buffer-mode)
           :select t :size 0.25 :align 'below)

          ("*rg*" :select t)
          ("\\`\\*edit-indirect .+\\*\\'" :regexp t :popup t :select t :size 0.4 :align 'below)
          ;; ("*Emacs Log*" :size 0.3 :align 'right)
          )))
#+end_src

*** popper

#+begin_src emacs-lisp :lexical t
(use-package popper
  :hook (after-init-hook . popper-mode)
  :init
  (setq popper-display-control t)
  (setq popper-reference-buffers
        `("\\*Pp Eval Output\\*"
          "\\*Pp Macroexpand Output\\*"
          ;; compilation-mode

          nodejs-repl-mode
          inferior-emacs-lisp-mode
          inferior-python-mode
          shell-mode

          shellc-command-mode
          ,shell-command-buffer-name
          ,shell-command-buffer-name-async
          "^\\*D2 Watch-"

          term-mode
          "^\\*terminal\\*"
          "^\\*ansi-term\\*"

          eshell-mode
          "^\\*eshell\\*"

          vterm-mode
          "^\\*vterm\\*"

          quickrun--mode
          "^\\*quickrun\\*"
          "^\\*eshell-quickrun\\*"))

  (setq popper-display-function #'my/popper-display-switch)

  (defvar my/popper-switches
    '((bottom . 0.4) (right . 0.5) (left . 0.99)))

  (defun my/popper-display-switch (buffer &optional alist)
    (unless (get 'my/popper-switches 'current-index)
      (put 'my/popper-switches 'current-index 0))
    (let* ((switch (nth (get 'my/popper-switches 'current-index)
                        my/popper-switches))
           (win-conf `((side . ,(car switch))
                       (slot . 1)
                       (window-width . ,(cdr switch))
                       (window-height . ,(cdr switch)))))
      (select-window (display-buffer-in-side-window buffer (append alist win-conf)))))

  (defun popper-switch ()
    (interactive)
    (when-let* ((window (caar popper-open-popup-alist)))
      (let* ((idx (get 'my/popper-switches 'current-index))
             (next-idx (% (1+ idx) (length my/popper-switches)))
             (args (or (and (memq (car (nth idx my/popper-switches)) '(right left))
                            '(2 . 0))
                       '(3 . 1)))
             (ratio (/ (float (- (nth (car args) (window-edges window))
                                 (nth (cdr args) (window-edges window))))
                       (nth (car args) (window-edges (frame-root-window))))))
        (popper-close-latest)
        (put 'my/popper-switches 'current-index next-idx)
        (setcdr (nth idx my/popper-switches) ratio)))
    (popper-open-latest))
  )

(keymap-global-set "s-s" #'popper-switch)
(keymap-global-set "s-i" #'popper-cycle)
(keymap-global-set "s-t" #'popper-toggle)
(keymap-global-set "s-u" #'vterm-new)
#+end_src

*** ibuffer

#+begin_src emacs-lisp :lexical t
(use-package ibuffer
  :hook (ibuffer-mode-hook . ibuffer-mode-setup)
  :bind
  (("C-x C-b" . ibuffer)
   :map ibuffer-mode-map
   ("G" . ibuffer-toggle)
   ("=" . ibuffer-diff-buffers))
  :init
  (setq ibuffer-expert t
        ibuffer-display-summary nil
        ibuffer-show-empty-filter-groups nil
        ibuffer-marked-char ?*)

  (defun ibuffer-toggle ()
    "Toggle to show or hide all filtered buffers in `ibuffer-mode'."
    (declare (modes ibuffer-mode))
    (interactive)
    (ibuffer-update 'show-all))

  (defun ibuffer-diff-buffers (&optional switches)
    "Display difference of two marked buffers in `'ibuffer-mode'."
    (declare (modes ibuffer-mode))
    (interactive (list (diff-switches)))
    (if-let* ((bufs (ibuffer-get-marked-buffers))
              ((= (length bufs) 2)))
        (diff-buffers (car bufs) (cadr bufs) switches)
      (user-error "diff: Must be two marked buffers")))

  (setq ibuffer-maybe-show-predicates '(my/ibuffer-not-show-predicate))
  (defun my/ibuffer-not-show-predicate (buf)
    (with-current-buffer buf
      (or (string-suffix-p ".el.gz" (buffer-name))
          (string-match "^\\*" (buffer-name))
          (memq major-mode ibuffer-help-buffer-modes)
          (and (string-match "^ " (buffer-name))
               (null buffer-file-name)))))

  (setq ibuffer-fontification-alist
        '((35 (or (string-suffix-p ".el.gz" (buffer-name))
                  (string-match "^\\*" (buffer-name))
                  (memq major-mode ibuffer-help-buffer-modes)
                  (and (string-match "^ " (buffer-name))
                       (null buffer-file-name)))
              font-lock-doc-face)
          (100 (derived-mode-p 'dired-mode) dired-directory)))

  (with-eval-after-load 'diredfl
    (setq ibuffer-marked-face 'diredfl-flag-mark
          ibuffer-deletion-face 'diredfl-deletion
          ibuffer-title-face 'diredfl-number
          ibuffer-filter-group-name-face 'diredfl-dir-name))

  (setq ibuffer-formats
        '((mark " " (name 20 20 :left :elide)
                " " modified read-only locked
                " " (size-h 7 -1 :right)
                " " (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " " name)))

  (defun ibuffer-mode-setup ()
    "Setup ibuffer mode."
    (ibuffer-auto-mode)
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'alphabetic)
      (ibuffer-do-sort-by-alphabetic)))

  :config

  (use-package ibuffer-vc :demand t)

  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size"
     :inline t
     :header-mouse-map ibuffer-size-header-map
     :summarizer
     (lambda (column-strings)
       (cl-loop for s in column-strings
                sum (get-text-property (1- (length s)) 'size s) into total
                finally return (file-size-human-readable total))))
    (let ((size (buffer-size)))
      (propertize (file-size-human-readable size)
                  'size size)))
  )

;; ;; Collapse
;; (defun ibuffer-collapse-all-filter-groups ()
;;   "Collapse all filter groups at once"
;;   (interactive)
;;   (setq ibuffer-hidden-filter-groups
;;         (mapcar #'car (ibuffer-current-filter-groups-with-position)))
;;   (ibuffer-update nil t))

;; ;; "Expand all filter groups at once"
;; (defun ibuffer-expand-all-filter-groups ()
;;   (interactive)
;;   (setq ibuffer-hidden-filter-groups nil)
;;   (ibuffer-update nil t))

#+end_src

*** undo                                                                  :undo:

#+begin_src emacs-lisp :lexical t
(use-package simple
  ;; :hook (after-init-hook . undo-setup)
  :init
  (setq undo-no-redo t)
  ;; (defun undo-setup ()

  ;; BUG https://lists.gnu.org/archive/html/bug-gnu-emacs/2022-12/msg01661.html
  ;; invalid-read-syntax
  ;; jump after inserted text after undo-redo
  ;; (psearch-patch primitive-undo
  ;;   (psearch-forward '`(goto-char . ,rest)
  ;;                    t (lambda (_ bounds)
  ;;                        (when (= psearch-count-current 5)
  ;;                          (delete-region (car bounds) (cdr bounds)))
  ;;                        t)
  ;;                    5))
  ;;

  ;; SEE https://github.com/oantolin/emacs-config/blob/master/my-lisp/block-undo.el
  (defun my/block-undo (fn &rest args)
    "Apply FN to ARGS in such a way that it can be undone in a single step."
    (undo-boundary)
    (with-undo-amalgamate
      (apply fn args)))

  ;; TODO wrap indent function
  (dolist (fn '(kmacro-call-macro
                kmacro-exec-ring-item
                apply-macro-to-region-lines
                apheleia-format-buffer
                my/format))
    (advice-add fn :around #'my/block-undo)))
#+end_src

*** undo-fu-session                                                       :undo:

#+begin_src emacs-lisp :lexical t
(use-package undo-fu-session
  :hook (after-init-hook . undo-fu-session-global-mode)
  :init
  (setq undo-fu-session-incompatible-files
        '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'")))
#+end_src

*** vundo                                                                 :undo:

#+begin_src emacs-lisp :lexical t
(use-package vundo
  :hook (vundo-mode-hook . vundo-mode-setup)
  :bind
  (("C-c u" . vundo)
   :map vundo-mode-map
   ("l" . vundo-forward)
   ("h" . vundo-backward)
   ("j" . vundo-next)
   ("k" . vundo-previous)
   ("s" . vundo-goto-last-saved))
  :init
  (setq vundo-window-max-height 5)
  (defun vundo-mode-setup ()
    (and hl-line-mode (hl-line-mode 'toggle))
    (binky-margin-local-mode -1)))
#+end_src

*** undo-hl                                                               :undo:

#+begin_src emacs-lisp :lexical t :tangle no
(use-package undo-hl
  :hook ((text-mode-hook prog-mode-hook) . undo-hl-mode)
  :config
  (appendq! undo-hl-undo-commands '(meow-undo meow-redo))
  (setq undo-hl-flash-duration 0.15))
#+end_src

*** atomic-chrome

#+begin_src emacs-lisp :lexical t
(use-package atomic-chrome
  :hook (after-init-hook . atomic-chrome-start-server)
  :init
  (setq atomic-chrome-create-file-strategy `(,(list (concat my/dir-cache "atomic"))))
  (setq atomic-chrome-buffer-open-style 'full)
  (setq atomic-chrome-auto-remove-file t)
  (setq atomic-chrome-make-file-save-initial-contents t)
  (setq atomic-chrome-url-major-mode-alist
        '(("ramdajs\\.com"           . js-ts-mode)
          ("codesandbox\\.io"        . js-ts-mode)
          ("w3schools\\.com"         . js-ts-mode)
          ("jsfiddle\\.net"          . js-ts-mode)
          ("github\\.com"            . gfm-mode)
          ("gitlab\\.com"            . gfm-mode)
          ("reddit\\.com"            . gfm-mode)
          ("emacs-china\\.org"       . gfm-mode)
          ("stackexchange\\.com"     . gfm-mode)
          ("stackoverflow\\.com"     . gfm-mode)
          ("leetcode\\.com"          . typescript-ts-mode)
          ("typescriptlang\\.org"    . typescript-ts-mode)
          ("react\\.docschina\\.org" . js-jsx-mode)
          ("react\\.dev"             . js-jsx-mode)
          ("play\\.d2lang\\.com"     . d2-ts-mode)))

  :config
  ;; HACK change major mode if website extension is wrong
  (defun atomic-edit-setup ()
    (let ((infos (atomic-chrome-get-info (current-buffer))))
      (when (and buffer-file-name
                 (string= (nth 2 infos) ".js")
                 (string-match-p "react\\.docschina\\.org" (nth 0 infos))
                 (not (eq major-mode 'js-jsx-mode)))
        (js-jsx-mode))))
  (add-hook 'atomic-chrome-edit-mode-hook #'atomic-edit-setup)
  )
#+end_src

*** hungry-delete

#+begin_src emacs-lisp :lexical t
(use-package hungry-delete
  :hook (after-init-hook . global-hungry-delete-mode)
  :config (setq-default hungry-delete-chars-to-skip " \t\f\v"))
#+end_src

*** coercion

#+begin_src emacs-lisp :lexical t
(use-package coercion
  :bind-keymap
  ("C-c c" . coercion-command-map))
#+end_src

*** consult-todo                                                     :jump:todo:

#+begin_src emacs-lisp :lexical t
(use-package consult-todo
  :init
  (setq consult-todo-cache-threshold 2)
  (setq consult-todo-narrow
        '((?t . "TODO")
          (?f . "FIXME")
          (?h . "HACK")
          (?k . "WORKAROUND")
          (?r . "REQUIRE")
          (?s . "SEE")
          (?p . "PR")
          (?i . "ISSUE")
          (?c . "DISCUSSION")
          (?n . "NOTE")
          (?x . "XXX")
          (?b . "BUG")
          (?w . "WONTFIX")
          (?d . "DEPRECATED"))))
#+end_src

*** edit-indirect

#+begin_src emacs-lisp :lexical t
(use-package edit-indirect
  :commands edit-indirect-buffer-indirect-p
  :init
  (defun my/edit-indirect ()
    "Edit indirectly according to `major-mode'"
    (interactive)
    (pcase major-mode
      ('snippet-mode (yas-edit-elisp-indirect))
      ((or 'markdown-mode 'gfm-mode) (markdown-edit-code-block)))))
#+end_src

*** wgrep

#+begin_src emacs-lisp :lexical t
(use-package wgrep
  :init
  (setq wgrep-change-readonly-file t)
  (setq wgrep-auto-save-buffer t))
#+end_src

*** rg                                                                  :search:

#+begin_src emacs-lisp :lexical t
(use-package rg
  :hook (rg-mode-hook . rg-mode-setup)
  :bind
  (("C-c s" . rg-menu)
   :map rg-mode-map
   ("<"    . compilation-first-error)
   (">"    . compilation-last-error)
   ("n"    . compilation-next-error)
   ("p"    . compilation-previous-error)
   ("\C-o" . compilation-display-error)
   ("\C-n" . next-error-no-select)
   ("\C-p" . previous-error-no-select)
   ("M-n"  . rg-next-file)
   ("M-p"  . rg-prev-file)
   ("w"    . rg-forward-history)
   ("b"    . rg-back-history)
   ("R"    . rg-replace)
   ("?"    . rg-menu))

  :init
  (setq rg-ignore-case 'smart
        rg-command-line-flags '("-z" "--pcre2"))

  (defun rg-mode-setup ()
    (goto-address-mode -1))

  :config

  (defun rg-replace (new-str)
    "Replace matched result in rg-mode buffer."
    ;; SEE https://emacs.stackexchange.com/a/72155
    (interactive (list (minibuffer-with-setup-hook
                           (lambda () (set-mark (minibuffer-prompt-end)))
                         (read-string "Rg replace matched string with: "
                                      (pcase-let ((`(,begin . ,length)
                                                   (car rg-match-positions)))
                                        (buffer-substring-no-properties
                                         begin (+ length (marker-position begin))))))))
    (let* ((stop-pos (point))
           (keep-asking t)
           (replace-stop nil)
           (prompt (format "Replace match string with %s: (y,n,q,Q,!,.) ?" new-str))
           (start (or (cl-position-if
                       (lambda(x) (>= x (point)))
                       (mapcar (lambda(x) (+ (marker-position (car x)) (cdr x)))
                               rg-match-positions))
                      (length rg-match-positions)))
           (replaces (nconc (cl-subseq rg-match-positions start)
                            (cl-subseq rg-match-positions 0 start))))
      (wgrep-change-to-wgrep-mode)
      (unwind-protect
          (catch 'quit
            (catch 'stop
              (dolist (cur-match replaces)
                (goto-char (setq stop-pos (car cur-match)))
                (let ((replace-p (not keep-asking)))
                  (when keep-asking
                    (catch 'pass
                      (while-let ((key (single-key-description (read-key prompt) t)))
                        (when (member key '("Q" "q"))
                          (wgrep-abort-changes)
                          (rg-recompile)
                          (throw 'quit nil))
                        (when (member key '("C-g" "ESC" "." "!" "y"
                                            "Y" "SPC" "n" "N" "DEL"))
                          (setq keep-asking (not (string= key "!")))
                          (setq replace-p (member key '("." "!" "y" "Y" "SPC")))
                          (setq replace-stop (member key '("C-g" "ESC" ".")))
                          (throw 'pass nil)))))
                  (when replace-p
                    (let ((begin (marker-position (car cur-match))))
                      (delete-region begin (+ begin (cdr cur-match)))
                      (insert new-str)))
                  (when replace-stop (throw 'stop nil)))))
            (wgrep-finish-edit))
        (goto-char stop-pos))))
  (rg-menu-transient-insert "Rerun" "R" "Replace" #'rg-replace))
#+end_src

*** simpleclip

#+begin_src emacs-lisp :lexical t
;; NOTE command-key [super] couldn't identifiled in emacs -nw
(use-package simpleclip
  :hook (after-init-hook . simpleclip-mode)
  :init
  (setq simpleclip-less-feedback t
        simpleclip-unmark-on-copy t)

  ;; HACK support vterm-mode
  (advice-add 'simpleclip-paste :override #'av/simpleclip-paste)
  (defun av/simpleclip-paste ()
    "Paste the contents of the system clipboard at the point."
    (interactive)
    (let ((str-val (simpleclip-get-contents)))
      (unless str-val
        (error "No content to paste"))
      (cond
       ((eq major-mode 'vterm-mode)
        (let ((inhibit-read-only t))
          (vterm-goto-char (point))
          (cl-letf (((symbol-function 'insert-for-yank) #'vterm-insert))
            (insert-for-yank str-val))))
       (buffer-read-only
        (error "Buffer is read-only"))
       ((derived-mode-p 'term-mode)
        (term-send-raw-string str-val))
       (t
        (when (use-region-p)
          (delete-region (region-beginning) (region-end)))
        (push-mark (point) t)
        (insert-for-yank str-val)))
      (when (and (not (minibufferp))
                 (not simpleclip-less-feedback)
                 (simpleclip-called-interactively-p 'interactive))
        (message "pasted from clipboard"))))
  )
#+end_src

*** copy-as-format

#+begin_src emacs-lisp :lexical t
(use-package copy-as-format
  :demand t
  :bind
  ("s-C" . simpleclip-copy-as-format)
  :init
  (defun simpleclip-copy-as-format ()
    "Copy the current line or active region and add it to the system clipboard as
GitHub/Slack/JIRA/HipChat/... formatted code.  Format defaults to
`copy-as-format-default'.  The buffer will not be modified.
With a prefix argument prompt for the format."
    (interactive)
    (let* ((text (copy-as-format--extract-text))
           (format (if current-prefix-arg
                       (completing-read "Format: "
                                        (mapcar 'car copy-as-format-format-alist)
                                        nil t "" nil copy-as-format-default)
                     copy-as-format-default))
           (func (cadr (assoc format copy-as-format-format-alist))))
      (when (eq (length text) 0)
        (error "No text selected"))
      (when (not (fboundp func))
        (error "Missing or invalid format function for `%s'" format))
      (simpleclip-set-contents (funcall func text (use-region-p)))
      (setq deactivate-mark t))))

;; TODO write alignment command based-on this library
;; (use-package delim-col)
#+end_src

*** binky                                                                 :jump:

#+begin_src emacs-lisp :lexical t
(use-package binky
  :hook (after-init-hook . binky-mode)
  :init
  (setq binky-recent-sort-by 'frequency
        binky-preview-in-groups t
        binky-margin-string nil
        binky-indicator-side 'right
        binky-command-prefix nil
        binky-hl-use-pulse t)
  (setq binky-back-mark ?')
  (setq binky-preview-column
        '((mark    0.03  4)
          (name    0.20  15)
          (line    0.04   6)
          (project 0.14  nil)
          (context 0     nil)))
  :config
  (require 'binky-margin)
  (binky-margin-mode))
#+end_src

*** xref                                                                  :jump:

#+begin_src emacs-lisp :lexical t
(use-package xref
  :init
  (setq xref-history-storage 'xref-window-local-history
        xref-search-program #'ripgrep
        xref-show-xrefs-function 'xref-show-definitions-completing-read
        xref-show-definitions-function 'xref-show-definitions-completing-read))
#+end_src

*** goto-addr                                                             :jump:

#+begin_src emacs-lisp :lexical t
(use-package goto-addr
  :hook ((after-init-hook . global-goto-address-mode)
         (prog-mode-hook . goto-address-prog-mode)))
#+end_src

*** webjump

#+begin_src emacs-lisp :lexical t
(use-package webjump
  :init
  (setq webjump-sites
        '(;; Internet search engines.
          ("StackOverFlow" . [simple-query "stackoverflow.com"
                                           "stackoverflow.com/search?q=" ""])
          ("Google" . [simple-query "www.google.com"
                                    "www.google.com/search?q=" ""])
          ("Github" . [simple-query "www.github.com"
                                    "www.github.com/search?q=" ""])
          ("Melpa" . [simple-query "melpa.org"
                                   "melpa.org/#/?q=" ""])
          ("Baidu" . [simple-query "www.baidu.com"
                                   "www.baidu.com/s?wd=" ""])
          ("Zhihu" . [simple-query "www.zhihu.com"
                                   "www.zhihu.com/search?type=content&q=" ""])
          ("V2ex" . [simple-query "www.sov2ex.com"
                                  "www.sov2ex.com/?q=" ""])
          ("Wiki" . [simple-query "wikipedia.org"
                                  "wikipedia.org/wiki/" ""])))
  :config
  ;; HACK support visual selection texts in webjump()
  (defun ad/webjump-read-string-enable-visual (prompt)
    "Patch for visual selection avaible"
    (let* ((region-text (if (use-region-p)
                            (buffer-substring-no-properties
                             (region-beginning)
                             (region-end)) nil))
           (input (read-string (concat prompt ": ") region-text)))
      (if (webjump-null-or-blank-string-p input) nil input)))
  (advice-add 'webjump-read-string :override #'ad/webjump-read-string-enable-visual))
#+end_src

*** paren

#+begin_src emacs-lisp :lexical t
(use-package paren
  :hook (after-init-hook . (lambda () (show-paren-mode -1)))
  :init
  (setq show-paren-style 'parenthesis
        show-paren-delay 0
        show-paren-context-when-offscreen 'overlay))
#+end_src

*** elec-pair

#+begin_src emacs-lisp :lexical t
(use-package elec-pair
  :hook (after-init-hook . electric-pair-mode))
#+end_src

*** isolate                                                          :edit:pair:

#+begin_src emacs-lisp :lexical t
(use-package isolate
  :demand t
  :config
  (add-hook 'isolate-add-mode-hook #'my/meow-motion-temporary))
#+end_src

*** diff-mode                                                             :diff:

#+begin_src emacs-lisp :lexical t
(use-package diff-mode
  :init
  ;; disable smerge-refine with set `diff-refine' to nil
  (setq diff-refine 'navigation))

;; ;; A comprehensive visual interface to diff & patch
;; (use-package ediff
;;   :hook (;; show org ediffs unfolded
;;          ;; (ediff-prepare-buffer . outline-show-all)
;;          ;; restore window layout when done
;;          (ediff-quit-hook . winner-undo))
;;   :init
;;   (setq ediff-window-setup-function 'ediff-setup-windows-plain)
;;   (setq ediff-split-window-function 'split-window-horizontally)
;;   (setq ediff-merge-split-window-function 'split-window-horizontally))
#+end_src

*** smerge-mode                                                       :diff:git:

#+begin_src emacs-lisp :lexical t
(use-package smerge-mode
  :hook (smerge-mode-hook . my/smerge-setup)
  :bind
  (:map smerge-basic-map
   ;; move
   ("n" . smerge-vc-next-conflict)
   ("f" . smerge-first)
   ("l" . smerge-last)
   ("x" . smerge-next-file)
   ;; choose
   ("a" . smerge-keep-all)
   ("m" . smerge-keep-upper)
   ("b" . smerge-keep-base)
   ("o" . smerge-keep-lower)
   ("c" . smerge-keep-current)
   ;; diff
   ("SPC" . smerge-conflict-preview-or-scroll)
   ("<"   . smerge-diff-base-upper)
   (">"   . smerge-diff-base-lower)
   ("="   . smerge-diff-upper-lower)
   ("e"   . smerge-ediff)
   ("R"   . smerge-refine)
   ;; edit
   ("s"   . smerge-swap)
   ("C"   . smerge-combine-with-next)
   ("r"   . smerge-resolve)
   ("C-r" . smerge-resolve-all)
   ("u"   . undo)
   ("U"   . undo-redo))
  :init
  (setq smerge-change-buffer-confirm nil
        ;; smerge-command-prefix ""
        smerge-refine-ignore-whitespace nil)

  (defun my/smerge-setup ()
    ;; (my/transient-smerge)
    ;; make sure call `smerge-first' after disable `save-place-local-mode'
    ;; see `add-hook' doc about order
    (smerge-first))

  (defun smerge-first ()
    "Jump to first conflict in the buffer."
    (interactive)
    (goto-char (point-min))
    (unless (looking-at smerge-begin-re)
      (smerge-next)))

  (defun smerge-last ()
    "Jump to first conflict in the buffer."
    (interactive)
    (goto-char (point-max))
    (smerge-prev))

  (defun smerge-conflict-preview-or-scroll ()
    "Preview or scorll conflict region."
    (interactive)
    (smerge-match-conflict)
    (let* ((rev (match-beginning 0))
           (buf (get-buffer "*smerge-preview*"))
           win)
      (unless (and buf (equal rev (buffer-local-value 'orig-rev buf)))
        (copy-to-buffer "*smerge-preview*" (match-beginning 0) (match-end 0))
        ;; SEE https://emacs.stackexchange.com/a/32817
        ;; (with-current-buffer "*smerge-preview*"
        ;;   (set (make-local-variable 'orig-rev) rev))
        (setf (buffer-local-value 'orig-rev buf) rev))
      (if (setq win (get-buffer-window buf))
          (with-selected-window win
            (condition-case nil
                (scroll-up)
              (error
               (goto-char (point-min)))))
        (display-buffer buf nil))))

  (defun smerge-next-file ()
    "Jump to next conflicted file."
    (interactive)
    (vc-find-conflicted-file)
    (smerge-first)
    (smerge-refine 2)))
#+end_src

*** jinx                                                                 :spell:

#+begin_src emacs-lisp :lexical t
(use-package jinx)
#+end_src

*** tool

#+begin_src emacs-lisp :lexical t
(use-package profiler
  :init
  (setq profiler-report-leaf-mark  ">")
  (defun ad/profiler-bytes-h (str)
    "reformat with human-readeable size"
    (let ((s (cl-count ?, str)))
      (cond
       ((= s 1) (concat (substring str 0 -4) " K"))
       ((= s 2) (concat (substring str 0 -8) " M"))
       ((>= s 3) (concat (substring str 0 -12) " G"))
       (t str))))
  (advice-add 'profiler-format-number :filter-return #'ad/profiler-bytes-h))
#+end_src

*** etrace
#+begin_src emacs-lisp :lexical t
(use-package etrace)
#+end_src

*** reverso                                                          :translate:

#+begin_src emacs-lisp :lexical t
(use-package reverso)
#+end_src

*** xr

#+begin_src emacs-lisp :lexical t
;; SEE https://www.emacswiki.org/emacs/RegularExpression
(use-package xr)
#+end_src

*** pinyin                                                             :chinese:

#+begin_src emacs-lisp :lexical t
;; REQUIRE brew install opencc
(use-package opencc)
(use-package pinyinlib :demand t)
#+end_src

*** pandoc-mode

#+begin_src emacs-lisp :lexical t
(use-package pandoc-mode)
#+end_src

*** ddp                                                                   :data:

#+begin_src emacs-lisp :lexical t
(use-package ddp)
#+end_src

*** proxy-mode                                                         :network:

#+begin_src emacs-lisp :lexical t
(use-package proxy-mode
  :init
  (when-let* ((http (getenv "HTTP")))
    (setq proxy-mode-env-http-proxy (concat "http://" http))
    (setq proxy-mode-emacs-http-proxy
          `(("http"     . ,http)
            ("https"    . ,http)
            ("ftp"      . ,http)
            ("no_proxy" . "127.0.0.1"))))

  (when-let* ((sock (getenv "SOCKS")))
    (setq proxy-mode-emacs-socks-proxy
          `("Default server"
            ,(substring sock 0 -5)
            ,(substring sock -4 nil)
            5)))
  )
#+end_src

*** keycast

#+begin_src emacs-lisp :lexical t
(use-package keycast
  :init
  (setq keycast-mode-line-format "%k%c%r"))
#+end_src

*** keyfreq

#+begin_src emacs-lisp :lexical t
(use-package keyfreq
  :hook ((after-init-hook . keyfreq-mode)
         (keyfreq-mode-hook . keyfreq-autosave-mode))
  :init
  (setq keyfreq-excluded-regexp
        '(;; built-in
          "\\`\\(mouse\\|scroll\\|keyboard\\|clipboard\\|minibuffer\\|package\\)-.*\\'"
          "\\`\\(backward\\|forward\\|move\\|isearch\\|describe\\|eval\\|exit\\)-.*\\'"
          "\\`\\(delete\\|kill\\|quit\\|save\\|abort\\|self\\|term\\|xterm\\)-.*\\'"
          "\\`\\(pcomplete\\|y-or-n-p\\|previous\\|next\\|right\\|left\\|zap\\)-.*\\'"
          "\\`\\(suspend\\|execute-extended\\|transient\\|indent\\electric\\)-.*\\'"
          "\\`\\(profiler-report\\|compilation\\|smerge\\)-.*\\'"
          ;; third-party
          "\\`\\(keyfreq\\|vertico\\|evil\\|corfu\\|vundo\\|yas\\|vterm\\)-.*\\'"
          "\\`\\(magit\\|helpful\\|web-mode\\|ilog\\|hungry-delete\\|meow\\)-.*\\'"
          "\\`\\(markdown-insert\\|markdown-table\\|my/transient\\|sis-set\\)-.*\\'"
          "\\`\\(acm\\|yaml-electric\\)-.*\\'"
          ))

  (setq keyfreq-excluded-commands
        '(
          undefined ignore mwheel-scroll hippie-expand newline newline-and-indent
          yank indent-for-tab-command push-button choose-completion
          comint-previous-input comint-send-input compile-goto-error embark-act dired
          dired-do-async-shell-command goto-line ispell-minor-check js-mode
          magit-mode-bury-buffer markdown-outdent-or-delete org-beginning-of-line
          org-ctrl-c-ctrl-c org-cycle org-delete-backward-char
          org-end-of-line org-force-self-insert org-return org-self-insert-command
          org-todo orgtbl-self-insert-command handle-switch-frame
          pixel-scroll-precision))
  :config

  ;; TODO support transient keybindings https://github.com/magit/transient/issues/113
  ;; HACK filter <menu-bar> bindings
  (defun ad/keyfreq-where-is (command)
    (string-join
     (cl-remove-if
      (lambda (key)
        (string-match-p "<\\(menu\\|vertical-scroll\\|horizontal-scroll\\)-bar>" key))
      (mapcar 'key-description (where-is-internal command)))
     ", "))
  (advice-add 'keyfreq-where-is :override #'ad/keyfreq-where-is)
  )
#+end_src

*** dwim-shell-command                                                   :shell:

#+begin_src emacs-lisp :lexical t
;; TODO rewrite a shell-enhanced plugin
(use-package dwim-shell-command
  :commands dwim-shell-command-on-marked-files
  :init
  (defun my/open-with=vscode ()
    (interactive)
    (dwim-shell-command-on-marked-files
     "Open current file in vscode."
     (if (eq system-type 'darwin)
         (if (derived-mode-p 'prog-mode)
             (format "code --goto '<<f>>':%d:%d"
                     (current-line)
                     (current-column))
           "open '<<f>>'")
       "setsid -w xdg-open '<<f>>'")
     :shell-args '("-x" "-c")
     :silent-success t
     :utils (if (eq system-type 'darwin)
                "open"
              "xdg-open"))))
;;(use-package aider)
#+end_src

*** gptel

#+begin_src emacs-lisp :lexical t
;; (require 'gptel-curl)
;; (require 'gptel-gemini)
;; (use-package gptel
;;   :demand t
;;   :init
;;   ;; OPTIONAL configuration
;;   (setq gptel-model 'gemini-1.5-pro-latest
;;         gptel-backend (gptel-make-gemini "Gemini"
;;                         :key (getenv "GEMINI_API_KEY")
;;                         :stream t)))
#+end_src

*** epg-config

#+begin_src emacs-lisp :lexical t
(use-package epg-config
  :init
  ;; to read passphrase from minibuffer
  (setq epg-pinentry-mode 'loopback))

;; (use-package pass
;;   :init
;;   (setq pass-show-keybindings nil))
#+end_src

*** auth-source                                                       :security:

#+begin_src emacs-lisp :lexical t
(use-package auth-source
  :commands auth-source-user-and-password)

(use-package authinfo-color-mode
  :mode ("authinfo.gpg\\'" . authinfo-color-mode)
  :init
  (advice-add 'authinfo-mode :override #'authinfo-color-mode))
#+end_src

*** package-lint                                                           :dev:

#+begin_src emacs-lisp :lexical t
(use-package package-lint
  :hook (emacs-lisp-mode-hook . elisp-package-setup)
  :init
  (defun elisp-package-setup ()
    "Setup flymake backends for elisp package file."
    (when-let* ((filepath (buffer-file-name))
                ((string-prefix-p borg-drones-directory filepath))
                ((package-lint-looks-like-a-package-p)))
      (require 'package-lint-flymake)
      (package-lint-flymake-setup))))
#+end_src

*** license-templates                                                      :dev:

#+begin_src emacs-lisp :lexical t
(use-package license-templates)
#+end_src

*** bench-multi                                                            :dev:

#+begin_src emacs-lisp :lexical t

;; TODO display use ctable tabulist ?
(cl-defmacro bench-multi (&key (times 1) forms ensure-equal raw)
  "Return Org table as a list with benchmark results for FORMS.
Runs FORMS with `benchmark-run-compiled' for TIMES iterations.

When ENSURE-EQUAL is non-nil, the results of FORMS are compared,
and an error is raised if they aren't `equal'.  If the results are
sequences, the difference between them is shown with
`seq-difference'.

When RAW is non-nil, the raw results from
`benchmark-run-compiled' are returned instead of an Org table
list.

If the first element of a form is a string, it's used as the
form's description in the bench-multi-results; otherwise, forms
are numbered from 0.

Before each form is run, `garbage-collect' is called."
  ;; MAYBE: Since `bench-multi-lexical' byte-compiles the file, I'm not sure if
  ;; `benchmark-run-compiled' is necessary over `benchmark-run', or if it matters.
  (declare (indent defun))
  (let*((keys (gensym "keys"))
        (result-times (gensym "result-times"))
        (header '(("Form" "x fastest" "Total runtime" "# of GCs" "Total GC runtime")
                  hline))
        ;; Copy forms so that a subsequent call of the macro will get the original forms.
        (forms (cl-copy-list forms))
        (descriptions (cl-loop for form in forms
                               for i from 0
                               collect (if (stringp (car form))
                                           (prog1 (car form)
                                             (setf (nth i forms) (cadr (nth i forms))))
                                         i))))
    `(unwind-protect
         (progn
           (defvar bench-multi-results nil)
           (let* ((bench-multi-results (make-hash-table))
                  (,result-times (sort (list ,@(cl-loop for form in forms
                                                        for i from 0
                                                        for description = (nth i descriptions)
                                                        collect `(progn
                                                                   (garbage-collect)
                                                                   (cons ,description
                                                                         (benchmark-run-compiled ,times
                                                                           ,(if ensure-equal
                                                                                `(puthash ,description ,form bench-multi-results)
                                                                              form))))))
                                       (lambda (a b)
                                         (< (cl-second a) (cl-second b))))))
             ,(when ensure-equal
                `(cl-loop with ,keys = (hash-table-keys bench-multi-results)
                          for i from 0 to (- (length ,keys) 2)
                          unless (equal (gethash (nth i ,keys) bench-multi-results)
                                        (gethash (nth (1+ i) ,keys) bench-multi-results))
                          do (if (sequencep (gethash (car (hash-table-keys bench-multi-results)) bench-multi-results))
                                 (let* ((k1) (k2)
                                        ;; If the difference in one order is nil, try in other order.
                                        (difference (or (setq k1 (nth i ,keys)
                                                              k2 (nth (1+ i) ,keys)
                                                              difference (seq-difference (gethash k1 bench-multi-results)
                                                                                         (gethash k2 bench-multi-results)))
                                                        (setq k1 (nth (1+ i) ,keys)
                                                              k2 (nth i ,keys)
                                                              difference (seq-difference (gethash k1 bench-multi-results)
                                                                                         (gethash k2 bench-multi-results))))))
                                   (user-error "Forms' bench-multi-results not equal: difference (%s - %s): %S"
                                               k1 k2 difference))
                               ;; Not a sequence
                               (user-error "Forms' bench-multi-results not equal: %s:%S %s:%S"
                                           (nth i ,keys) (nth (1+ i) ,keys)
                                           (gethash (nth i ,keys) bench-multi-results)
                                           (gethash (nth (1+ i) ,keys) bench-multi-results)))))
             ;; Add factors to times and return table
             (if ,raw
                 ,result-times
               (append ',header
                       (bench-multi-process-results ,result-times)))))
       (unintern 'bench-multi-results nil))))

(defun bench-multi-process-results (results)
  "Return sorted RESULTS with factors added."
  (setq results (sort results (-on #'< #'cl-second)))
  (cl-loop with length = (length results)
           for i from 0 below length
           for description = (car (nth i results))
           for factor = (pcase i
                          (0 "fastest")
                          (_ (format "%.2f" (/ (cl-second (nth i results))
                                               (cl-second (nth 0 results))))))
           collect (append (list description factor)
                           (list (format "%.6f" (cl-second (nth i results)))
                                 (cl-third (nth i results))
                                 (if (> (cl-fourth (nth i results)) 0)
                                     (format "%.6f" (cl-fourth (nth i results)))
                                   0)))))
#+end_src

*** ct                                                                   :color:

#+begin_src emacs-lisp :lexical t
(use-package ct)
#+end_src

*** term                                                                 :shell:

#+begin_src emacs-lisp :lexical t
(use-package term
  :init

  ;; HACK rewrite to display ansi-term with pop style
  (defun av/ansi-term (program &optional new-buffer-name)
    (interactive (list (read-from-minibuffer "Run program: "
                                             (or explicit-shell-file-name
                                                 (getenv "ESHELL")
                                                 shell-file-name))))
    ;; Pick the name of the new buffer.
    (setq term-ansi-buffer-name
          (if new-buffer-name
              new-buffer-name
            (if term-ansi-buffer-base-name
                (if (eq term-ansi-buffer-base-name t)
                    (file-name-nondirectory program)
                  term-ansi-buffer-base-name)
              "ansi-term")))
    (setq term-ansi-buffer-name (concat "*" term-ansi-buffer-name "*"))
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (let ((prog (split-string-shell-command program)))
      (setq term-ansi-buffer-name
            (apply #'term-ansi-make-term term-ansi-buffer-name (car prog)
                   nil (cdr prog))))
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-char-mode)
    (let (term-escape-char)
      (term-set-escape-char ?\C-x))
    ;; use pop style rather than switch to buffer
    (pop-to-buffer-same-window term-ansi-buffer-name))
  (advice-add 'ansi-term :override #'av/ansi-term)

  )
#+end_src

*** vterm                                                                :shell:

install: ~brew install libvterm cmake~

#+begin_src emacs-lisp :lexical t
(use-package vterm
  :hook (vterm-mode-hook . vterm-setup)
  :commands (vterm vterm-other-window)
  :bind
  (:map vterm-mode-map
   ("M-u" . nil)
   ("M-i" . nil))
  :init
  ;; (setq vterm-term-environment-variable "xterm-kitty")
  (setq vterm-buffer-name "*vterm*")

  (defun vterm-setup ()
    (meow-mode -1)
    (and hl-line-mode (hl-line-mode 'toggle)))

  (defun vterm--get-buffers ()
    "Return a list of vterm buffers."
    (--filter (eq (buffer-local-value 'major-mode it) 'vterm-mode)
              (buffer-list)))

  (defun vterm--get-windows ()
    "Return a list of windows display vterm buffers."
    (--filter (eq (buffer-local-value 'major-mode (window-buffer it))
                  'vterm-mode)
              (window-list nil 'no-minibuf)))

  (defun vterm-new (&optional other)
    "Create an new interactive Vterm buffer.
If here is a window display vterm buffer, then creat a new one in that window.
Or create a new one in other window."
    (interactive "P")
    (let ((len (length (vterm--get-buffers)))
          (wins (vterm--get-windows))
          (dir default-directory))
      (when (> len 0)
        (cl-incf len)
        (while (get-buffer (format "%s<%d>" vterm-buffer-name len))
          (cl-incf len)))
      (let ((arg (and (> len 0) len)))
        (if (not wins)
            (vterm-other-window arg)
          (let ((default-directory dir)
                (win (if (memq (selected-window) wins)
                         (car wins)
                       (car (last wins)))))
            (select-window
             (or (and other
                      (if (or (window-full-width-p win)
                              (eq 'vterm-mode
                                  (buffer-local-value
                                   'major-mode
                                   (window-buffer
                                    (window-in-direction 'left win)))))
                          (split-window-right nil win)
                        (split-window-below nil win)))
                 win))
            (vterm arg)
            ;; FIXME side windows cannot be divided, if be diveide enabled,
            ;; balance windows afterwards
            ;; (balance-windows (window-parent win))
            )))))

  ;; (defun vterm-new-other-window ()
  ;;   "Open new vterm in other window."
  ;;   (interactive)
  ;;   (vterm-new 'other))

  ;;   (defun vterm-toggle ()
  ;;     "Toggle to show or hide vterm window."
  ;;     (interactive)
  ;;     (let* ((bufs (vterm--get-buffers))
  ;;            (win (car (vterm--get-windows))))
  ;;       (cond
  ;;        ((not bufs) (vterm-other-window))
  ;;        ((not win) (switch-to-buffer-other-window (car bufs)))
  ;;        (t (delete-window win)))))
  ;;
  ;;   (defun vterm-cycle (&optional backward)
  ;;     "Cycle the vterm buffer.
  ;; If BACKWARD is non-nil, cycle vterms buffers reversely"
  ;;     (interactive "P")
  ;;     (let* ((bufs (vterm--get-buffers))
  ;;            (win (car (vterm--get-windows))))
  ;;       (cond
  ;;        ((not bufs) (vterm-other-window))
  ;;        ((not win) (switch-to-buffer-other-window (car bufs)))
  ;;        (t (save-selected-window
  ;;             (let* ((order-bufs (-sort #'string-lessp (-map #'buffer-name bufs) ))
  ;;                    (new-buf
  ;;                     (-> (if backward #'1- #'1+)
  ;;                         (funcall (-elem-index (buffer-name (window-buffer win)) order-bufs))
  ;;                         (mod (length order-bufs))
  ;;                         (nth order-bufs))))
  ;;               (select-window win)
  ;;               (switch-to-buffer new-buf)
  ;;               (message "Switch to %S" new-buf)))))))
  )
#+end_src

*** quickrun                                                         :shell:dev:

#+begin_src emacs-lisp :lexical t
(use-package quickrun
  :hook (quickrun--mode-hook . quickrun-setup)
  :init
  (setq quickrun-focus-p nil
        quickrun-timeout-seconds 100)

  (defun quickrun-setup ()
    "docstring"
    (setq-local cursor-in-non-selected-windows nil))

  :config
  (prependq! quickrun-file-alist
             '(("\\.d2\\'" . "d2")))

  (prependq! quickrun--major-mode-alist
             '((lisp-interaction-mode . "elisp")
               (typescript-ts-mode . "typescript")
               (js-ts-mode . "javascript")
               (bash-ts-mode . "shellscript")
               (d2-ts-mode . "d2")))

  (prependq! quickrun--language-alist
             '(("d2" . ((:command . "d2")
                        (:cmdopt . "--layout=elk --theme=102")
                        (:exec . ("%c %o --watch %s %s.svg"))
                        (:compile-only . "%c %o %s %s.svg")
                        (:remove . ("%s.svg" "%s.png"))
                        (:tempfile nil)
                        (:description . "Compile d2 diagram and display")))))

  )

(defun my/run ()
  "Running Current Buffer."
  (interactive)
  (cond
   ((member major-mode '(markdown-mode gfm-mode)) (grip-start-preview))
   ((member major-mode '(web-mode html-mode mhtml-mode)) (imp-visit-buffer))
   (t (run-general! quickrun-region quickrun))))
#+end_src

*** devdocs                                                                :dev:

#+begin_src emacs-lisp :lexical t
(defun-mixed!
 devdocs-at-point
 word
 "Search devdocs.io"

 ;; SEE https://devdocs.io/help
 (browse-url (format "https://devdocs.io/#q=%s" (url-hexify-string query)))

 ;; SEE https://github.com/egoist/devdocs-desktop#using-homebrew
 ;; (shell-command (format "open devdocs://search/%s" (url-hexify-string query)))
 )
#+end_src

*** cheatsheet                                                             :dev:

#+begin_src emacs-lisp :lexical t
(defvar cheatsheets-ref-lists nil)
(defun cheatsheets-open (&optional cn)
  "Browser selected reference in cheatsheets.me.
If CN is non-nil, search in zh-CN documentation."
  (interactive "P")
  (when-let* ((ref (completing-read
                    "Select quickref: "
                    (with-memoization cheatsheets-ref-lists
                      (mapcar #'file-name-sans-extension
                              (string-split
                               (shell-command-to-string
                                "gh api --jq '.[].name' /repos/Fechin/reference/contents/source/_posts"))))
                    nil t)))
    (browse-url (concat "https://cheatsheets.zip/" (if cn (concat "zh-CN/docs/" ref ".html") ref)))))
#+end_src

*** flymake

#+begin_src emacs-lisp :lexical t
(use-package flymake
  :hook ((prog-mode-hook
          markdown-mode-hook
          yaml-ts-mode-hook
          web-vue-mode-hook) . flymake-mode)
  :init
  (setq flymake-indicator-type nil
        flymake-margin-indicator-position nil
        flymake-fringe-indicator-position nil
        flymake-no-changes-timeout 20))

;; REQUIRE
;; pip install ruff-lsp yamllint
;; brew install shellcheck tidy-html5 jq
;; gem install mdl
;; luarocks install luacheck
;; npm install -g less
(use-package flymake-collection
  :hook (after-init-hook . flymake-collection-hook-setup)
  :init
  (setq flymake-collection-hook-config
        '(((python-ts-mode python-mode) .
           (flymake-collection-ruff
            (python-flymake :disable t)))
          ((sh-mode bash-ts-mode) .
           (flymake-collection-shellcheck
            (sh-shellcheck-flymake :disabled t)))
          ((yaml-mode yaml-ts-mode) .
           flymake-collection-yamllint)
          ;; REQUIRE brew install tidy-html5
          ((web-mode html-ts-mode mhtml-mode html-mode) .
           (flymake-collection-html-tidy))
          ;; ((js-mode js-ts-mode typescript-mode typescript-ts-mode web-vue-mode
          ;;           typescript-tsx-mode) .
          ;; (flymake-collection-eslint))
          ((json-mode json-ts-mode) flymake-collection-jq)
          ((markdown-mode gfm-mode) flymake-collection-markdownlint)
          (c-ts-mode flymake-collection-clang)
          ((lua-mode lua-ts-mode) flymake-collection-luacheck)
          ((ruby-mode ruby-ts-mode) . (flymake-collection-rubocop))
          (sql-mode flymake-collection-sql-lint)
          (nxml-mode flymake-collection-xmllint)
          (less-mode flymake-collection-less))))

(use-package flymake-collection-clang
  :config
  (appendq! flymake-collection-clang-args '("-Wno-gnu")))

(use-package relint)

(use-package flymake-relint
  :hook ((emacs-lisp-mode-hook lisp-interaction-mode-hook) . flymake-relint-setup))

(use-package flymake-bridge
  :hook (lsp-bridge-mode-hook . flymake-bridge-setup))
#+end_src

*** editorconfig                                                        :format:

#+begin_src emacs-lisp :lexical t

;; (use-package editorconfig
;;   :hook (after-init-hook . editorconfig-mode))
#+end_src

*** apheleia                                                            :format:

#+begin_src emacs-lisp :lexical t
(use-package apheleia
  :hook ((typescript-ts-mode-hook js-ts-mode-hook)
         . apheleia-mode)
  :init
  (setq apheleia-hide-log-buffers t)
  (defun my/format ()
    "Formatting current buffer."
    (interactive)
    (unless buffer-read-only
      (pcase major-mode
        ((or gitconfig-mode emacs-lisp-mode lisp-interaction-mode)
         (indent-whole-buffer))
        (_ (call-interactively #'apheleia-format-buffer)))))

  ;; do not format if functions return non-nil
  (setq apheleia-skip-functions
        '(yas-current-field active-minibuffer-window))

  :config
  (alist-set! apheleia-formatters
              '((shfmt . ("shfmt" "-i" "2" "-bn" "-ci"))
                (stylua . ("stylua" "--search-parent-directories" "-"))
                (d2fmt . ("d2" "fmt" filepath))))
  (alist-set! apheleia-mode-alist
              '((python-mode . (ruff isort))
                (python-ts-mode . (ruff isort))
                ((sh-mode bash-ts-mode) . shfmt)
                (d2-ts-mode . d2fmt)
                (markdown-mode . prettier-markdown)
                (gfm-mode . prettier-markdown)
                (ruby-ts-mode . rubocop)
                (nxml-mode . prettier-html)
                (js-jsx-mode . prettier-javascript)
                (tsx-ts-mode . prettier-typescript))))
#+end_src

*** vc                                                                     :git:

#+begin_src emacs-lisp :lexical t
(use-package vc
  :init
  ;; (setq vc-display-status t)
  (setq vc-follow-symlinks t))
#+end_src

*** vc-msg                                                                 :git:

#+begin_src emacs-lisp :lexical t
(use-package vc-msg
  :init
  (setq vc-msg-show-at-line-beginning-p nil
        vc-msg-newbie-friendly-msg ""))
#+end_src

*** git-cliff                                                              :git:

#+begin_src emacs-lisp :lexical t
(use-package git-cliff
  :init
  (setq git-cliff-extra-dir (expand-file-name "git-cliff/" my/dir-etc))
  ;; Integrate to `magit-tag'
  (with-eval-after-load 'magit-tag
    (transient-append-suffix 'magit-tag
      '(1 0 -1)
      '("c" "changelog" git-cliff-menu))))
#+end_src

*** gitignore-templates                                                    :git:

#+begin_src emacs-lisp :lexical t
(use-package gitignore-templates
  :init
  (setq gitignore-templates-api 'gitignore.io)
  ;; Integrate with `magit-gitignore'
  (with-eval-after-load 'magit-gitignore
    (require 'gitignore-templates nil t)
    (transient-append-suffix 'magit-gitignore '(0)
      ["Template"
       ("n" "new file" gitignore-templates-new-file)
       ("i" "insert pattern" gitignore-templates-insert)])))
#+end_src

*** git-link                                                               :git:

#+begin_src emacs-lisp :lexical t
(use-package git-link
  :init
  (setq git-link-use-commit t)
  (defun ad/git-link-to-system-clip (&rest _)
    "Copy to git link to system clip rather than kill-ring."
    (when (and kill-ring
               (fboundp #'simpleclip-set-contents))
      (simpleclip-set-contents
       (substring-no-properties (pop kill-ring)))))
  (advice-add 'git-link--new :after #'ad/git-link-to-system-clip)
  ;; Integrate with `magit-tool'
  )
#+end_src

*** browse-at-remote                                                       :git:
#+begin_src emacs-lisp :lexical t
(use-package browse-at-remote)
#+end_src

*** transient

#+begin_src emacs-lisp :lexical t
(use-package transient
  :bind
  (:map transient-map
   ("ESC" . transient-quit-one)
   ("<escape>" . transient-quit-one))
  ;; NOTE unload builtin transient if needed
  :preface
  (unload-feature 'transient t)
  :init
  (setq transient-highlight-mismatched-keys nil
        transient-detect-key-conflicts t)
  (setq transient-show-during-minibuffer-read nil
        transient-hide-during-minibuffer-read t))

(use-package transient-showcase)
#+end_src

*** magit                                                                  :git:

#+begin_src emacs-lisp :lexical t
(use-package with-editor)
(use-package git-modes
  :mode
  ("\\.\\(rg\\|docker\\)ignore\\'" . gitignore-mode)
  ("\\.gitconfig\\'" . gitconfig-mode))

(use-package emacsql)

(use-package magit
  :config
  (setq magit-slow-confirm nil)
  (setq magit-auto-revert-immediately t)
  (setq magit-save-repository-buffers 'dontask
        magit-bury-buffer-function #'magit-restore-window-configuration)
  (setq magit-show-long-lines-warning nil)
  (setopt magit-format-file-function #'magit-format-file-nerd-icons)

  ;; Display fullframe buffer in some magit-*-modes
  (defvar magit-modes-display-fullframe-selected
    '(magit-log-mode magit-reflog-mode magit-submodule-list-mode)
    "List of modes related to magit to display in fullframe.")

  (defun my/magit-display-buffer-fullframe-selected (buffer)
    "Display BUFFER, filling entier frame if BUFFER's major mode included in
 `magit-modes-display-fullframe-selected'.
Otherwise, behave like `magit-display-buffer-traditional'."
    (if (member (buffer-local-value 'major-mode buffer)
                magit-modes-display-fullframe-selected)
        (display-buffer buffer '(magit--display-buffer-fullframe))
      (magit-display-buffer-traditional buffer)))
  (setq magit-display-buffer-function #'my/magit-display-buffer-fullframe-selected)

  ;;; status

  (setq magit-status-show-hashes-in-headers t
        magit-status-goto-file-position nil
        magit-status-initial-section '(2))
  (prependq! magit-section-initial-visibility-alist
             '((untracked . hide)
               (unpushed  . show)))

  (magit-add-section-hook 'magit-status-sections-hook
                          'magit-insert-modules
                          nil t)

  ;; Predefined status command arguments
  ;; (with-eval-after-load 'magit-status
  ;;   (put 'magit-status-mode 'magit-diff-default-arguments
  ;;        '("--no-ext-diff" "--ignore-submodules=all")))

  ;; TODO when move to any staged/unstaged section, close other siblings files
  ;; ;; expand section when jump to it
  ;; (defun my/magit-section-ensure-visible (section)
  ;;   (when (oref section hidden)
  ;;     (magit-section-show section)))
  ;; (add-hook 'magit-section-movement-hook #'my/magit-section-ensure-visible)

  ;;; commit

  (setq magit-commit-reword-override-date nil
        magit-commit-show-diff nil)

  ;; Set to meow-insert-mode automatically
  (add-hook 'git-commit-setup-hook #'meow-insert-mode)

  ;;; submodule

  (setq magit-submodule-remove-trash-gitdirs t)
  (setq magit-submodule-list-sort-key '("B<U" . t))
  (setq magit-submodule-list-columns
        `(("Path"     25 ,#'magit-modulelist-column-path
           ())
          ("Version"  24 ,#'magit-repolist-column-version
           ((:sort magit-repolist-version<)))
          ("Branch"   7 ,#'magit-repolist-column-branch
           ())
          ("B<P" 5 ,#'magit-repolist-column-unpulled-from-pushremote
           ((:right-align t)
            (:sort <)))
          ("B<U" 5 ,#'magit-repolist-column-unpulled-from-upstream
           ((:right-align t)
            (:sort <)))
          ("B>P" 5 ,#'magit-repolist-column-unpushed-to-pushremote
           ((:right-align t)
            (:sort <)))
          ("B>U" 5 ,#'magit-repolist-column-unpushed-to-upstream
           ((:right-align t)
            (:sort <)))
          ("S"   3 ,#'magit-repolist-column-stashes
           ((:right-align t)
            (:sort <)))
          ("B"   3 ,#'magit-repolist-column-branches
           ((:right-align t)
            (:sort <)))))

  ;;; tag

  ;; Predefined log command arguments
  (with-eval-after-load 'magit-log
    (put 'magit-log-mode 'magit-log-default-arguments
         '("--graph" "-n256" "--decorate" "--color")))

  ;; ;; preview blob buffer in magit-log-mode
  ;; (add-hook 'magit-section-movement-hook 'magit-log-maybe-update-blob-buffer)
  ;; (keymap-set magit-log-mode-map "C-<return>" magit-blog-show-or-scroll)
  ;; (defun magit-blob-show-or-scroll (args)
  ;;   "docstring"
  ;;   (interactive)
  ;;   )

  ;;; diff

  ;; SEE https://magit.vc/manual/magit/Diff-Options.html
  (setq magit-diff-refine-hunk 'all
        magit-diff-refine-ignore-whitespace t
        magit-diff-paint-whitespace-lines 'all)

  ;;; blame
  (setq magit-blame-styles
        '((margin
           (margin-format    . (" %a, %s%f" ""))
           (margin-width     . 60)
           (margin-face      . magit-blame-margin)
           (margin-body-face . magit-blame-dimmed))))
  )
#+end_src

*** elfeed

#+begin_src emacs-lisp :lexical t
(use-package elfeed
  :init
  (setq url-queue-timeout 30)
  (setq elfeed-initial-tags '(unread))
  (setq elfeed-search-filter "@6-months-ago")
  ;; (setq elfeed-show-entry-switch #'switch-to-buffer
  ;;       elfeed-show-entry-delete #'elfeed-kill-buffer)
  (setq elfeed-curl-extra-arguments '("--proxy" "socks5://127.0.0.1:7890"
                                      "--retry" "3"
                                      "--insecure"))
  (setq elfeed-feeds
        '(("https://sachachua.com/blog/feed" sacha emacs)
          ("https://planet.emacslife.com/atom.xml" emacs)
          ("http://www.masteringemacs.org/feed/" emacs)
          ("http://pragmaticemacs.com/feed/" emacs)
          ("https://oremacs.com/atom.xml" emacs)
          ("http://xahlee.info/emacs/emacs/blog.xml" emacs xah)
          ("https://pinecast.com/feed/emacscast" emacs)
          ("https://emacstil.com/feed.xml" emacs)
          ("https://emacstalk.codeberg.page/podcast/index.xml" emacs)
          ("https://manateelazycat.github.io/feed.xml" lazycat emacs)
          ("https://news.ycombinator.com/rss" hacker news)))

  ;; SEE https://emacs-china.org/t/elfeed-nerd-icons/26125
  (setq  elfeed-search-print-entry-function #'elfeed-search-print-entry--my)
  (defun elfeed-search-print-entry--my (entry)
    "Print ENTRY to the buffer."
    (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
           (date-width (car (cdr elfeed-search-date-format)))
           (title (concat (or (elfeed-meta entry :title)
                              (elfeed-entry-title entry) "")
                          ;; NOTE: insert " " for overlay to swallow
                          " "))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title (when feed (or (elfeed-meta feed :title)
                                      (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (mapconcat (lambda (s)
                                  (propertize s 'face 'elfeed-search-tag-face))
                                tags ","))
           (title-width (- (frame-width)
                           ;; (window-width (get-buffer-window (elfeed-search-buffer) t))
                           date-width elfeed-search-trailing-width))
           (title-column (elfeed-format-column
                          title (elfeed-clamp
                                 elfeed-search-title-min-width
                                 title-width
                                 elfeed-search-title-max-width) :left))
           ;; Title/Feed ALIGNMENT
           (align-to-feed-pixel (+ date-width
                                   (max elfeed-search-title-min-width
                                        (min title-width
                                             elfeed-search-title-max-width)))))
      (insert (propertize date 'face 'elfeed-search-date-face) " ")
      (insert (propertize title-column 'face title-faces 'kbd-help title))
      (put-text-property (1- (point)) (point) 'display
                         `(space :align-to ,align-to-feed-pixel))
      (when feed-title
        (insert " " (propertize feed-title 'face 'elfeed-search-feed-face) " "))
      (when tags (insert "(" tags-str ")"))))

  :config

  (use-package elfeed-webkit
    :demand t
    :init
    (advice-add 'elfeed-show-mode :after #'elfeed-webkit-toggle)
    :bind
    (:map elfeed-show-mode-map
     ("%" . elfeed-webkit-toggle)))

  (defun eli/elfeed-overview ()
    "Get an overview of all feeds."
    (interactive)
    (with-current-buffer (elfeed-search-buffer)
      (elfeed-save-excursion
       (let* ((inhibit-read-only t)
              (standard-output (current-buffer)))
         (erase-buffer)
         (eli/elfeed-overview--update-list)
         (dolist (entry elfeed-search-entries)
           (funcall elfeed-search-print-entry-function entry)
           (insert "\n"))
         (setf elfeed-search-last-update (float-time))))
      (when (zerop (buffer-size))
        ;; If nothing changed, force a header line update
        (force-mode-line-update))
      (run-hooks 'elfeed-search-update-hook)))

  (defun eli/elfeed-overview--update-list ()
    "Update `elfeed-search-filter' list."
    (let* ((head (list nil))
           (tail head)
           (count 0))
      (dolist (feed elfeed-feeds)
        (let* ((lexical-binding t)
               (filter (elfeed-search-parse-filter
                        (concat "=" (or (car-safe feed)
                                        feed))))
               (func (byte-compile (elfeed-search-compile-filter filter))))
          (with-elfeed-db-visit (entry feed)
                                (when (funcall func entry feed count)
                                  (setf (cdr tail) (list entry)
                                        tail (cdr tail)
                                        count (1+ count))
                                  (elfeed-db-return)))))
      (let ((entries (cdr head))
            (elfeed-search-sort-function
             (lambda (a b)
               (let ((a-date (elfeed-entry-date a))
                     (b-date (elfeed-entry-date b)))
                 (> a-date b-date)))))
        (setf entries (sort entries elfeed-search-sort-function))
        (setf elfeed-search-entries
              entries))))
  (push elfeed-db-directory recentf-exclude))
#+end_src

*** project

#+begin_src emacs-lisp :lexical t
(use-package project
  :demand t
  :init
  (setq project-vc-merge-submodules nil)
  (defun my/dir-find-file ()
    "Command to find file in selected directory for `consult-dir'."
    (interactive)
    (call-interactively
     (if (string-prefix-p (file-truename (project-root (project-current t)))
                          (file-truename default-directory))
         #'project-find-file
       #'find-file))))
#+end_src

*** lsp-bridge

install: ~pthon3 -m pip install epc orjson sexpdata six paramiko ruff packaging~

#+begin_src emacs-lisp :lexical t
(use-package lsp-bridge
  :hook (after-init-hook . global-lsp-bridge-mode)
  :bind
  ("M-d" . lsp-bridge-doc-toggle)
  :init
  ;; Setup language
  (setq lsp-bridge-enable-org-babel t)
  (setq lsp-bridge-python-command (expand-file-name "lsp-bridge/python-lsp-bridge" borg-drones-directory))
  (setq lsp-bridge-python-multi-lsp-server "basedpyright_ruff")
  (setq lsp-bridge-lua-lsp-server "sumneko")
  (setq lsp-bridge-c-lsp-server "clangd")

  ;; Setup tsdk path in volar.json
  (defun tsdk-path-detect ()
    (let ((bin-path (string-trim (shell-command-to-string "command -v tsc"))))
      (string-replace "bin/tsc" "lib/node_modules/typescript/lib" bin-path)))
  (setq lsp-bridge-tsdk-path (tsdk-path-detect))

  (setq lsp-bridge-enable-inlay-hint t)
  (setq lsp-bridge-enable-completion-in-string t)
  ;; (setq lsp-bridge-completion-in-string-file-types '("vue" "dart"))

  ;; (setq lsp-bridge-completion-popup-predicates nil)
  ;; ;; Debug
  ;; (setq lsp-bridge-enable-log t)
  ;; (setq lsp-bridge-enable-debug t)

  (defun lsp-bridge-doc-toggle ()
    (interactive)
    (if (acm-frame-visible-p lsp-bridge-popup-documentation-frame)
        (acm-hide)
      (lsp-bridge-popup-documentation)))

  :config

  ;; Setup server
  (setq lsp-bridge-user-langserver-dir
        (expand-file-name "lsp-bridge/single" my/dir-etc))
  (setq lsp-bridge-user-multiserver-dir
        (expand-file-name "lsp-bridge/multi" my/dir-etc))

  (setq lsp-bridge-enable-diagnostics t
        lsp-bridge-disable-backup nil)

  (appendq! lsp-bridge-default-mode-hooks
            '(snippet-mode-hook
              git-commit-mode-hook
              mhtml-mode-hook
              html-mode-hook
              lua-ts-mode-hook
              astro-ts-mode-hook
              js-json-mode-hook
              moonbit-mode-hook
              web-vue-mode)))
#+end_src

Detect lang server

urls:
- [[https://github.com/typescript-language-server/typescript-language-server/blob/HEAD/docs/configuration.md][typescript-language-server]]
- [[https://github.com/Microsoft/vscode-eslint#settings-options][vscode-eslint]]
- [[https://github.com/neoclide/coc-css][coc-css]]
- [[https://github.com/neoclide/coc-json#configuration-options][coc-json]]
- [[https://github.com/redhat-developer/yaml-language-server#language-server-settings][yaml-language-server]]
- [[https://github.com/tailwindlabs/tailwindcss-intellisense/blob/master/packages/tailwindcss-language-service/src/util/languages.ts][tailwind-language-server]]
- [[https://github.com/aca/emmet-ls#readme][emmet-ls]]
- [[https://github.com/microsoft/vscode-eslint/blob/3147111b1bd430a9f29d7a66916e1d822eba3df3/package.json#L307-L316][eslint multy]]

yaml-language-server, coc-json implements schemastore supports, however
vscode-json-language-server not yet, which means need to add schemastore catalog
to vscode-json-language-server.json manually.

server detect order:
1. run   `lsp-bridge-get-multi-lang-server-by-project';
2. match `lsp-bridge-multi-lang-server-extension-list';
3. match `lsp-bridge-multi-lang-server-mode-list';
4. run   `lsp-bridge-get-single-lang-server-by-project';
5. match `lsp-bridge-single-lang-server-extension-list';
6. match `lsp-bridge-single-lang-server-mode-list';

#+begin_src emacs-lisp :lexical t
(with-eval-after-load 'lsp-bridge
  ;; base function
  ;; HACK filepath like "../.zshenv" will return nil if call `file-name-extension'
  ;; directly, so add a prefix to return zshenv
  (defun filepath-ext (filepath)
    (or (file-name-extension (concat "a" (file-name-nondirectory filepath))) ""))

  (defun typescript-ls-get-id (ext)
    (cond
     ((or (string= ext "js") (memq major-mode '(js-mode js-ts-mode)))
      "javascript")
     ((or (string= ext "ts") (eq major-mode 'typescript-ts-mode))
      "typescript")
     ((or (string= ext "jsx") (eq major-mode 'js-jsx-mode))
      "javascriptreact")
     ((or (string= ext "tsx") (eq major-mode 'tsx-ts-mode))
      "typescriptreact")))

  (defun css-ls-get-id (ext)
    (cond
     ((or (string= ext "css") (memq major-mode '(css-mode css-ts-mode)))
      "css")
     ((or (string= ext "scss") (eq major-mode 'scss-mode))
      "scss")
     ((or (string= ext "less") (eq major-mode 'less-css-mode))
      "less")))

  (defun web-file-get-server (ext)
    (cond
     ((or (member ext '("htm" "html"))
          (memq major-mode '(mhtml-mode html-mode html-ts-mode)))
      "html")
     ((or (member ext '("css" "less" "scss"))
          (memq major-mode '(css-mode css-ts-mode less-css-mode scss-mode)))
      "css")))

  (defun handlebar-p (ext)
    (or (member ext '("handlebars" "hbs"))
        (eq major-mode 'handlebars-mode)))

  (defun markdown-p (ext)
    (or (string= ext "md")
        (memq major-mode '(markdown-mode gfm-mode markdown-ts-mode))))

  ;; NOTE project-path return same value as filepath if lsp-bridge cannot detect project
  ;; so check it ahead, tailwindcss do not support single file mode
  (defun tailwindcss-p (project_path)
    (and (file-directory-p project_path)
         (directory-files
          project_path
          'full
          "tailwind\\.config\\.\\(j\\|cj\\|mj\\|t\\)s\\'")))

  (defun eslint-p (project_path)
    (and (file-directory-p project_path)
         (directory-files
          project_path
          'full
          "\\`\\(eslint\\.config\\.[m|c]?js\\|\\.eslintrc\\.\\(c?js\\|ya?ml\\|json\\)\\)\\'")))

  ;; customize func to define project path
  (setq lsp-bridge-get-project-path-by-filepath nil)

;;; multi-server detect
  (setq lsp-bridge-get-multi-lang-server-by-project #'my/bridge-multi-server-detect)

  (defun my/bridge-multi-server-detect (project_path filepath)
    "Return multi server config according to project extra requirements.
PROJECT_PATH and FILEPATH is needed."
    (save-excursion
      (let* ((ext (filepath-ext filepath))
             (tailwindcss-suffix (and (tailwindcss-p project_path) "_tailwindcss"))
             (eslint-suffix (and (eslint-p project_path) "_eslint")))
        (when (or tailwindcss-suffix eslint-suffix)
          (let ((server
                 (cond
                  ((member (typescript-ls-get-id ext)
                           '("javascriptreact" "typescriptreact"))
                   (concat "typescript_emmet" tailwindcss-suffix eslint-suffix))
                  ((member (typescript-ls-get-id ext)
                           '("javascript" "typescript"))
                   (concat "typescript" eslint-suffix))
                  ((web-file-get-server ext)
                   (concat (web-file-get-server ext) "_emmet" tailwindcss-suffix)))))
            (temp-log (format (concat "%s" (s-repeat 4 "\n%-13s: %S"))
                              (propertize "[lsp-bridge-multi-server]" 'face 'error)
                              "project_path" project_path
                              "file_path" filepath
                              "file_ext" ext
                              "start_server" server))
            server)))))

  (setq lsp-bridge-multi-lang-server-extension-list
        '((("tsx")   . "typescript_emmet")
          (("jsx")   . "javascript_emmet")
          (("html" "htm") . "html_emmet")
          (("css" "less" "scss") . "css_emmet")))

  (setq lsp-bridge-multi-lang-server-mode-list
        `(((python-mode python-ts-mode) . ,lsp-bridge-python-multi-lsp-server)
          ((js-jsx-mode) . "javascript_emmet")
          ((tsx-ts-mode) . "typescript_emmet")
          ((mhtml-mode html-mode html-ts-mode) . "html_emmet")
          ((css-mode css-ts-mode less-css-mode scss-mode) . "css_emmet")))

;;; single server detect
  ;; (setq lsp-bridge-get-single-lang-server-by-project #'my/bridge-single-server-detect)
  ;; (defun my/bridge-single-server-detect (project_path filepath)
  ;;   (save-excursion
  ;;     (let* ((ext (filepath-ext filepath)))
  ;;       (let ((server (cond
  ;;                      ((typescript-ls-get-id ext) "typescript-ls")
  ;;                      ((or (and ext (string= ext "toml"))
  ;;                           (memq major-mode '(toml-ts-mode conf-toml-mode)))
  ;;                       "toml-language-server"))))
  ;;         (temp-log (format (concat "%s" (s-repeat 4 "\n%-13s: %S"))
  ;;                           (propertize "[lsp-bridge-single-server]" 'face 'success)
  ;;                           "project_path" project_path
  ;;                           "file_path" filepath
  ;;                           "file_ext" ext
  ;;                           "start_server" server))
  ;;         server))))

  (prependq! lsp-bridge-single-lang-server-extension-list
             '((("toml") . "toml-language-server")
               (("vue")  . "volar")
               (("astro") . "astro-ls")
               (("mbt")  . "moonbit-ls")))

  (prependq! lsp-bridge-single-lang-server-mode-list
             '(((toml-ts-mode conf-toml-mode) . "toml-language-server")
               ((js-mode js-ts-mode typescript-ts-mode js-jsx-mode tsx-ts-mode)
                . "typescript-ls")
               (lua-ts-mode . "sumneko")
               (web-vue-mode . "volar")
               (astro-ts-mode . "astro-ls")
               (moonbit-mode . "moonbit-ls")))

  (setq lsp-bridge-get-language-id 'my/bridge-get-language-id)

  (defun my/bridge-get-language-id (project_path filepath server ext)
    (let ((id (pcase server
                ("typescript-ls" (typescript-ls-get-id ext))
                ("vscode-css-language-server" (css-ls-get-id ext))
                ("tailwindcss"
                 (pcase ext
                   ((pred typescript-ls-get-id) (typescript-ls-get-id ext))
                   ((pred markdown-p) "markdown")
                   ((pred handlebar-p) "handlebars")
                   ("res" "rescript")
                   (_ ext)))
                ("emmet-ls"
                 (pcase ext
                   ((pred typescript-ls-get-id) (typescript-ls-get-id ext))
                   ("erb" "eruby")
                   ((or "css" "html" "less" "sass" "scss" "svelte" "pug" "vue") ext)
                   (_ "html")))
                ("vscode-eslint-language-server"
                 (pcase ext
                   ((pred typescript-ls-get-id) (typescript-ls-get-id ext))
                   ((pred markdown-p) "markdown")
                   (_ ext))))))
      (temp-log (format (concat "%s" (s-repeat 5 "\n%-13s: %S"))
                        (propertize "[lsp-bridge-get-id]" 'face 'warning)
                        "project_path" project_path
                        "file_path" filepath
                        "file_ext" ext
                        "start_server" server
                        "lang_id" id))
      id))

  ;; server customize after start

  (add-hook 'lsp-bridge-mode-hook #'my/bridge-server-setup)
  (defun my/bridge-server-setup ()
    (run-with-timer
     3 nil
     (lambda()
       (with-current-buffer (current-buffer)
         (when (bound-and-true-p acm-backend-lsp-server-names)
           (let ((servers acm-backend-lsp-server-names))
             (when (member "tailwindcss" servers)
               (modify-syntax-entry ?- "w")
               (setq-local lsp-bridge-enable-completion-in-string t))
             (temp-log (format (concat "%s" (s-repeat 2 "\n%-13s: %S"))
                               (propertize "[lsp-bridge-servers]" 'face 'warning)
                               "current_buffer" (current-buffer)
                               "servers" servers))))))))
  )
#+end_src

*** acm

#+begin_src emacs-lisp :lexical t
;; FIXME can not detect frame switch between gui and tui, leads to crash.
(use-package acm
  :bind
  (:map acm-mode-map
   ("C-j" . nil)
   ("C-k" . nil)
   ;; ("C-;" . acm-switch-templates)
   )
  :init
  (setq acm-enable-quick-access nil
        acm-enable-tabnine nil
        acm-enable-doc nil)
  (setq acm-candidate-match-function 'orderless-flex)
  ;; yasnippet
  (setq acm-completion-backend-merge-order
        '("template-first-part-candidates"
          "template-second-part-candidates"
          "mode-first-part-candidates"
          "mode-second-part-candidates"))
  (setq acm-backend-yas-candidates-number 3
        acm-backend-yas-match-by-trigger-keyword t
        acm-backend-yas-show-trigger-keyword " [%s]")

  :config

  ;; (require 'acm-backend-lsp-workspace-symbol)
  ;; (setq acm-enable-lsp-workspace-symbol t)

  ;; enable acm cycle style
  (defun ad/acm-select-prev ()
    (interactive)
    (acm-menu-update
     (cond ((> acm-menu-index 0)
            (setq-local acm-menu-index (1- acm-menu-index)))
           ((> acm-menu-offset 0)
            (setq-local acm-menu-offset (1- acm-menu-offset)))
           (t (call-interactively #'acm-select-last)))))
  (advice-add 'acm-select-prev :override #'ad/acm-select-prev)

  (defun ad/acm-select-next ()
    (interactive)
    (acm-menu-update
     (cond ((< acm-menu-index (1- (length acm-menu-candidates)))
            (setq-local acm-menu-index (1+ acm-menu-index)))
           ((< (+ acm-menu-offset acm-menu-index) (1- (length acm-candidates)))
            (setq-local acm-menu-offset (1+ acm-menu-offset)))
           (t (call-interactively #'acm-select-first)))))
  (advice-add 'acm-select-next :override #'ad/acm-select-next)

  ;; ;; TODO write a acm-switch-template
  ;; (defun acm-switch-templates ()
  ;;   "docstring"
  ;;   (interactive))

  ;; FIXME wrapper of `lsp-bridge-toggle-sdcv-helper'
  (defun acm-sdcv-toggle ()
    "docstring"
    (interactive)
    (let ((inhibit-message t))
      (lsp-bridge-toggle-sdcv-helper)
      (acm-update)
      (acm-menu-update)))

  (defun ad/acm-doc-toggle ()
    (interactive)
    (if (acm-frame-visible-p acm-doc-frame)
        (progn
          (acm-doc-hide)
          (setq acm-enable-doc nil))
      (setq acm-enable-doc t)
      (acm-doc-try-show)))
  (advice-add 'acm-doc-toggle :override #'ad/acm-doc-toggle))
#+end_src

*** treesit                                                            :treesit:

#+begin_src emacs-lisp :lexical t
(use-package treesit
  :init
  ;; debug
  ;; (setq treesit--font-lock-verbose t)

  (setq treesit-font-lock-level 4)

  ;; command to build modules
  (defun treesit-build-modules ()
    "Build all treesit grammars."
    (interactive)
    (let ((default-directory (expand-file-name "tree-sitter-module" borg-drones-directory))
          (dest (expand-file-name "tree-sitter" user-emacs-directory)))
      (make-directory dest t)
      (shell-command
       (concat "INSTALL_DIR=" dest
               " EXTENSION_TAGS=1"
               " EXTENSION_WIKI_LINK=1"
               " JOBS=$(nproc) ./batch.sh&")))))

(setq major-mode-remap-alist
      '((c-mode . c-ts-mode)
        (c++-mode . c++-ts-mode)
        (conf-toml-mode . toml-ts-mode)
        (js-json-mode . json-ts-mode)
        (javascript-mode . js-ts-mode)
        (python-mode . python-ts-mode)
        ;; (markdown-mode . markdown-ts-mode)
        (sh-mode . bash-ts-mode)))
#+end_src

*** treesit-fold                                                       :treesit:

#+begin_src emacs-lisp :lexical t
(use-package treesit-fold)
#+end_src

*** built-in langs

#+begin_src emacs-lisp :lexical t
(use-package css-mode
  :init
  (setq css-indent-offset 2)
  (setq css-fontify-colors nil))

(use-package sh-script
  :init
  (setq sh-basic-offset 2
        sh-shell-file (executable-find "bash")))

(use-package js
  :mode "\\.[mc]js\\'"
  :init
  (setq js-indent-level 2
        js-chain-indent t
        js-jsx-indent-level 2))

(use-package conf-mode
  :mode ("\\.\\(ini\\|conf\\)\\'" "enchant.ordering"
         (("\\.tidyrc\\'") . conf-colon-mode)))

(use-package make-mode
  :mode ("\\(makefile\\|\\.mk\\)\\'" . makefile-gmake-mode))

(use-package yaml-ts-mode
  :mode "\\.\\(ya?ml\\|yamllint\\|clang-format\\)\\'")

(use-package json-ts-mode
  :mode "\\.\\(eslintrc\\(\\.json\\)?\\)\\'")

;; (use-package rust-ts-mode)
;;
;; (use-package toml-ts-mode)

(use-package tsx-ts-mode
  :mode "\\.tsx\\'")

(use-package dockerfile-ts-mode
  :mode "\\(?:Dockerfile\\(?:\\..*\\)?\\|\\.[Dd]ockerfile\\)\\'")

(use-package nxml-mode
  :hook (nxml-mode-hook . nxml-mode-setup)
  :init
  (defun nxml-mode-setup ()
    (setq-local fill-column 150)))

(use-package lua-ts-mode
  :init
  (setq lua-ts-mode-indent-offset 2))

(use-package c-ts-mode
  :init
  ;; google style
  (setq c-ts-mode-indent-offset 2
        c-ts-mode-indent-style 'gnu))
#+end_src

*** third-party langs

#+begin_src emacs-lisp :lexical t

(use-package typescript-ts-mode
  :mode "\\.ts\\'"
  :hook (typescript-ts-mode-hook . typescript-ts-mode-setup)
  :init
  (defun typescript-ts-mode-setup ()
    (add-hook 'post-self-insert-hook #'ah/typescript-generics-angle-pair nil t)))

(use-package web-mode
  ;; :hook (web-mode-hook . web-mode-setup)
  :mode "\\.\\(htm\\|html\\|phtml\\|php|[gj]sp\\|as[cp]x\\|erb\\|djhtml\\|hbs\\|ejs\\|jade\\|swig\\|tm?pl\\)$"
  :init
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-part-padding 2
        ;; web-mode-enable-auto-closing nil
        ;; web-mode-enable-auto-opening nil
        web-mode-enable-auto-pairing nil
        web-mode-enable-auto-quoting t
        ;; web-mode-enable-auto-expanding nil
        ;; web-mode-enable-auto-indentation nil
        web-mode-enable-current-element-highlight t
        ;; web-mode-enable-current-column-highlight nil
        ;; web-mode-enable-block-face t
        ;; web-mode-enable-part-face t
        ;; web-mode-enable-inlays t
        ;; web-mode-enable-sql-detection t
        ;; web-mode-enable-front-matter-block t
        ;; web-mode-enable-element-content-fontification nil
        ;; web-mode-enable-element-tag-fontification nil
        web-mode-enable-html-entities-fontification t)
  )

(use-package jq-ts-mode)

(use-package mermaid-mode
  :mode "\\.\\(mmd\\|mermaid\\)"
  :init
  (setq mermaid-output-format ".pdf"))

(use-package zig-ts-mode
  :mode "\\.zig\\'")

(use-package moonbit-mode
  :mode "\\.mbt\\'")

(use-package tera-mode
  :mode "\\.tera\\'")

(use-package csv-mode)

(use-package handlebars-mode)

(use-package ssh-config-mode)

(use-package graphql-mode)

(use-package pip-requirements)

(use-package adoc-mode)
#+end_src

*** elisp

#+begin_src emacs-lisp :lexical t
(use-package ielm
  :bind
  (:map inferior-emacs-lisp-mode-map
   ("C-l" . comint-clear-buffer))
  :init
  (setq ielm-noisy nil))

(use-package elisp-mode
  :hook (emacs-lisp-mode-hook . elisp-mode-setup)
  :init
  ;; define imenu regexp for elisp-mode
  (defun elisp-imenu-regexp-generate (item)
    "docstring"
    (list (nth 0 item)
          (concat "^\\s-*(" (regexp-opt (nth 1 item) t)
                  "\\s-+\\(" (rx lisp-mode-symbol)
                  (or (nth 2 item) "\\)")
                  ) 2))

  (setq my/elisp-iemnu-generic-expression
        (mapcar #'elisp-imenu-regexp-generate
                '(("Leafs" ("leaf"))
                  ("Customs" ("defcustom"))
                  ("Faces" ("defface"))
                  ("Commands" ("defun" "cl-defun" "transient-define-suffix")
                   "\\)\\(.*\n\\)+?\\s-*(interactive.*")
                  ("Macros" ("defmacro" "cl-defmacro" "cl-define-compiler-macro"))
                  ("Transients" ("transient-define-prefix" "transient-define-suffix"
                                 "transient-define-infix" "transient-define-argument"))
                  ("Functions"
                   ("defun" "cl-defun" "defun*" "defsubst" "cl-defsubst"
                    "define-inline" "define-advice" "defadvice" "define-skeleton"
                    "define-compilation-mode" "define-minor-mode"
                    "define-global-minor-mode" "define-globalized-minor-mode"
                    "define-derived-mode" "define-generic-mode" "defsetf"
                    "define-setf-expander" "define-method-combination"
                    "defgeneric" "cl-defgeneric" "defmethod" "cl-defmethod"
                    "ert-deftest"))
                  ("Variables" ("defvar" "defconst" "defconstant"
                                "defvar-local" "defvaralias"
                                "defparameter" "define-symbol-macro"))
                  ("Types" ("defgroup" "deftheme" "define-widget" "define-error"
                            "deftype" "cl-deftype" "cl-defstruct" "defstruct"
                            "defclass" "define-condition" "defpackage")))))

  (defun elisp-mode-setup ()
    (setq-local imenu-generic-expression my/elisp-iemnu-generic-expression)))

(use-package simple
  :init
  (setq eval-expression-print-length nil
        eval-expression-print-level nil))

(use-package pp
  :init
  (setq pp-default-function 'pp-28)
  (defun pp-macroexpand-all-expression (expression)
    "Macroexpand EXPRESSION all level and pretty-print its value."
    (interactive
     (list (read--expression "Macroexpand: ")))
    (pp-display-expression (macroexpand-all expression) "*Pp Macroexpand Output*"
                           pp-use-max-width)))

(use-package macroexpand
  :init
  (setq macrostep-expand-in-separate-buffer t
        macrostep-expand-compiler-macros nil))

;; SEE https://github.com/manateelazycat/lsp-bridge/commit/d25a63a1e7cca38fc931bb6ddb52acf590912685
(use-package electric
  :hook (after-init-hook . electric-indent-mode))

;; SEE https://emacs-china.org/t/2-3-4/11875/5
(use-package lisp-keyword-indent
  :hook (after-init-hook . lisp-keyword-indent-mode)
  :init (setq lisp-indent-function 'lisp-indent-function))

;; add extra font-lock for elisp
(use-package elispfl
  :after elisp-mode
  :config
  (elispfl-mode)
  (elispfl-ielm-mode))

(use-package eros
  :hook (after-init-hook . eros-mode))

(use-package elisp-demos
  :commands elisp-demos-find-demo
  :init
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))

(use-package helpful
  :init
  (setq helpful-switch-buffer-function #'display-buffer
        helpful-max-buffers nil)
  :bind
  ([remap describe-key]      . helpful-key)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-command]  . helpful-command)
  ([remap describe-function] . helpful-callable)
  ([remap describe-symbol]   . helpful-symbol))

(use-package info-colors
  :hook (Info-selection-hook . info-colors-fontify-node))

(use-package macrostep
  :init
  (setq macrostep-expand-in-separate-buffer t))

(use-package psearch :demand t)
#+end_src

*** python

#+begin_src emacs-lisp :lexical t
(use-package python
  :mode ("\\.pythonrc\\'" . python-ts-mode)
  :bind
  (:map inferior-python-mode-map
   ("C-l" . comint-clear-buffer)))
#+end_src

*** vue

#+begin_src emacs-lisp :lexical t
(define-derived-mode web-vue-mode web-mode "wVue"
  "Major mode for vue file based on web-mode.")
(add-to-list 'auto-mode-alist '("\\.vue\\'" . web-vue-mode))
#+end_src

*** focus

#+begin_src emacs-lisp :lexical t
(use-package focus)
#+end_src

*** olivetti

#+begin_src emacs-lisp :lexical t
(use-package olivetti
  :init
  (setq olivetti-body-width nil
        olivetti-style t))
#+end_src

*** TODO logos

to define a org presentation like in system craft
#+begin_src emacs-lisp :lexical t
(use-package logos
  :init
  (setq logos-hide-cursor t
        logos-hide-mode-line t
        logos-hide-header-line t
        logos-scroll-lock t
        logos-hide-buffer-boundaries t
        logos-buffer-read-only t
        logos-olivetti t
        logos-hide-fringe nil))
#+end_src

#+begin_src emacs-lisp :lexical t
(defun autocorrect-fix ()
  "Fix cjk formats error with `auto-correct'."
  (interactive)
  (when-let* (((executable-find "autocorrect"))
              (file (buffer-file-name)))
    (shell-command (format "autocorrect --fix %s" (shell-quote-argument file)))))
#+end_src

*** markdown

#+begin_src emacs-lisp :lexical t
(use-package markdown-mode)

(use-package md
  :mode ("\\.md\\'" . md-ts-mode)
  :hook (md-ts-mode-hook . md-toc-mode)
  :init
  (setq md-ts-mode-fontify-fenced-blocks-natively t))
#+end_src

*** grip-mode

#+begin_src emacs-lisp :lexical t
;; REQUIRE pip install grip colorama
(use-package grip-mode
  :commands grip-start-preview
  :config
  ;; BUG lose md code block background
  (setq grip-preview-use-webkit t))
#+end_src

*** org                                                                    :org:

#+begin_src emacs-lisp :lexical t
(use-package org
  :bind
  (("C-c l" . org-store-link)
   ("C-c a" . org-agenda)
   ("C-c c" . org-capture)
   ;; :map org-mode-map
   )
  :init

  (setq org-directory my/dir-org)
  (setq org-insert-mode-line-in-empty-file t)
  (setq org-imenu-depth 4)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "DOING(i)" "HANGUP(h)" "|" "DONE(d)" "CANCEL(c)")
          (sequence "⚑(T)" "🏴(I)" "❓(H)" "|" "✔(D)" "✘(C)"))
        org-todo-keyword-faces '(("HANGUP" . warning)
                                 ("❓" . warning))
        org-priority-faces '((?A . error)
                             (?B . warning)
                             (?C . success)))
  ;; agenda
  (setq org-agenda-files (list my/dir-org))
  ;; src
  (setq org-edit-src-content-indentation 0
        org-edit-src-auto-save-idle-delay 5
        org-src-ask-before-returning-to-edit-buffer nil)
  ;; (setq org-src-lang-modes)

  ;; tag
  (setq org-tags-column -80
        org-tags-sort-function #'org-string<
        org-log-done 'time
        org-fold-catch-invisible-edits 'smart
        org-startup-indented nil
        org-startup-folded 'overview
        org-ellipsis " ▾"
        org-pretty-entities t
        org-hide-emphasis-markers nil)

  ;; (setq org-archive-location )
  :config
  (require 'org-capture)
  (require 'org-agenda)

  (add-to-list 'org-structure-template-alist '("n" . "note"))
  (add-to-list 'org-export-backends 'md)

  ;; Use embedded webkit browser if possible
  (when (featurep 'xwidget)
    (push '("\\.\\(x?html?\\|pdf\\)\\'"
            .
            (lambda (file _link)
              (xwidget-webkit-browse-url (concat "file://" file) t)))
          org-file-apps))

  ;; auto format code before and after edit src block

  ;; (advice-add 'org-edit-src-code :before #'org-indent-block)
  (advice-add 'org-edit-src-exit :before #'my/format)
  )
#+end_src

*** org-capture

#+begin_src emacs-lisp :lexical t
(use-package org-capture
  :init
  (setq org-capture-templates
        `(("i" "Idea" entry (file ,(concat org-directory "/idea.org"))
           "*  %^{Title} %?\n%U\n%a\n")
          ("t" "Todo" entry (file ,(concat org-directory "/gtd.org"))
           "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
          ;; ("n" "Note" entry (file ,(concat org-directory "/note.org"))
          ;;  "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)
          ;; ("j" "Journal" entry (file+olp+datetree
          ;;                       ,(concat org-directory "/journal.org"))
          ;;  "*  %^{Title} %?\n%U\n%a\n" :clock-in t :clock-resume t)
          ("b" "Book" entry (file+olp+datetree
                             ,(concat org-directory "/book.org"))
           "* Topic: %^{Description}  %^g %? Added: %U")
          ("s" "Stock" entry (file+olp+datetree ,(concat "~/Desktop/stock" "/stock.org"))
           (function org-diary-template-for-stock)
           :time-prompt t
           :immediate-finish t
           :empty-lines-after 1))))
#+end_src

*** ox-gfm                                                                 :org:

#+begin_src emacs-lisp :lexical t :tangle no
(use-package ox-gfm
  :init (add-to-list 'org-export-backends 'gfm))
#+end_src

*** org-modern                                                             :org:

#+begin_src emacs-lisp :lexical t
(use-package org-modern
  :hook ((org-mode-hook . org-modern-mode)
         (org-agenda-finalize-hook . org-modern-agenda)
         ;; (org-modern-mode-hook . org-modern-setup)
         )
  :init
  (setq org-modern-star 'replace
        org-modern-tag nil
        org-modern-replace-stars "❶❷❸❹❺❻❼❽❾")
  (setq org-modern-list
        '((?* . "⭑")
          (?+ . "◼")
          (?- . "⬥")))

  ;; (defun org-modern-setup ()
  ;;   "Adapt `org-modern-mode'."
  ;;   ;; Disable Prettify Symbols
  ;;   ;; (setq prettify-symbols-alist nil)
  ;;   (prettify-symbols-mode 1))
  )
#+end_src

*** denote

#+begin_src emacs-lisp :lexical t
(use-package denote
  :demand t)
#+end_src

*** keybinding

#+begin_src emacs-lisp :lexical t
;; SEE https://github.com/magit/transient/wiki
;; SEE https://stackoverflow.com/a/1052296/13194984
;; SEE http://xahlee.info/emacs/emacs/emacs_key_notation_return_vs_RET.html
;; SEE http://xahlee.info/emacs/emacs/keystroke_rep.html
;; SEE https://www.masteringemacs.org/article/mastering-key-bindings-emacs

;;; Code:

(defun my/keyboard-quit ()
  "A general `keyboard-quit'.
The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   (t
    (keyboard-quit))))

(dolist (pair '(("C-g" . my/keyboard-quit)
                ("M-j" . scroll-other-window)
                ("M-k" . scroll-other-window-down)
                ("M-o" . toggle-one-window)
                ;; vscode style
                ("s-r" . consult-git-grep)
                ("s-p" . my/dir-find-file)
                ("s-/" . newcomment-toggle)))
  (keymap-global-set (car pair) (cdr pair)))

(defvar-keymap my/toggle-map
  :doc "Keymap for toggle commands."
  "o" #'toggle-one-window
  "p" #'toggle-profiler
  "e" #'toggle-debug-on-error
  "t" #'toggle-debug-on-quit
  "F" #'toggle-frame-fullscreen
  "C" #'toggle-truncate-lines
  "W" #'toggle-word-wrap
  "m" #'markdown-toggle-markup-hiding)
(keymap-set mode-specific-map "t" my/toggle-map)

(defvar-keymap my/ide-map
  :doc "Keymap for ide-like commands."
  "r" #'my/run
  "R" #'quickrun-shell
  "f" #'my/format
  ;; test
  ;; "c" #'testrun-nearest
  ;; "n" #'testrun-namespace
  ;; "b" #'testrun-file
  ;; "a" #'testrun-all
  ;; "l" #'testrun-last
  ;; doc
  "h" #'devdocs-at-point
  "H" #'helpful-at-point
  ;; git
  "v" #'vc-msg-show
  "j" #'browse-at-remote
  "J" #'git-link)
(keymap-set mode-specific-map "i" my/ide-map)

(defvar-keymap my/jump-map
  :doc "Keymap for jump commands"
  "f" #'flymake-goto-next-error
  "F" #'flymake-goto-prev-error
  "t" #'hl-todo-next
  "T" #'hl-todo-previous
  "b" #'binky-next-in-buffer
  "B" #'binky-previous-in-buffer
  "d" #'diff-hl-next-hunk
  "D" #'diff-hl-previous-hunk)
(keymap-set mode-specific-map "j" my/jump-map)

;; HACK resolve conflicts with diff-hl-command-help
(with-eval-after-load 'diff-hl
  (map-keymap (lambda (_key cmd) (put cmd 'repeat-map 'my/jump-map))
              my/jump-map))

(defvar-keymap ctl-x-7-map
  :doc "Keymap for `transpose-frame' commands"
  :repeat t
  "t" #'transpose-window-layout
  "v" #'flip-window-layout-vertically
  "h" #'flip-window-layout-horizontally
  "r" #'rotate-windows
  "b" #'rotate-windows-back
  "c" #'rotate-window-layout-clockwise
  "a" #'rotate-window-layout-counterclockwise)
(keymap-set ctl-x-map "7" ctl-x-7-map)

(defvar-keymap my/edit-map
  :doc "Keymap for structure edit commands."
  ;; isolate
  "a" #'isolate-quick-add
  "d" #'isolate-quick-delete
  "c" #'isolate-quick-change
  "A" #'isolate-long-add
  "D" #'isolate-long-delete
  "C" #'isolate-long-change)
(keymap-set mode-specific-map "e" my/edit-map)

;; (with-eval-after-load 'transient

;; (transient-define-prefix my/transient-buffer ()
;;   "Invoke commands about buffer"
;;   [["Info"
;;     ("N" "Base name" buffer-base-name)
;;     ("A" "Absolute path" file-absolute-path)
;;     ;; ("R" "relative path")
;;     ]
;;    ["Edit"
;;     ("r" "Revert buffer" revert-this-buffer)
;;     ("b" "Rename buffer" rename-buffer)
;;     ("f" "Rename file" rename-this-file)
;;     ("B" "Rename both" rename-both)
;;     ("d" "Delete both" delete-both)
;;     ]
;;    ["Content"
;;     ;; ("u" "change utf")
;;     ("u" "Dos2unix" dos2unix)
;;     ("U" "Unix2dos" unix2dos)]
;;    ])

;; )
#+end_src

*** envrionment                                                            :dev:

#+begin_src emacs-lisp :lexical t :tangle yes
;; for npm/pnpm project
;; create or add path
;; allow envrc
;; (defun my/env-add-path ()
;;   (interactive)
;;
;;   )
;; TODO switch envrc/mise accroding to project

;; (use-package envrc
;;   :mode ("\\.env\\(rc\\)?\\'" . envrc-file-mode)
;;   :hook (after-init-hook . envrc-global-mode)
;;   )

(use-package mise
  :hook (after-init-hook . global-mise-mode)
  ;; :init
  ;; (setq mise-debug t)
  )
#+end_src

*** combobulate                                                        :treesit:

#+begin_src emacs-lisp :lexical t :tangle no
(use-package combobulate
  :hook
  ((tsx-ts-mode-hook js-ts-mode-hook typescript-ts-mode-hook) . combobulate-mode)
  :init
  (setq combobulate-proffer-allow-numeric-selection t
        combobulate-flash-node nil
        combobulate-proffer-indicators "ox")
  :config
  ;; BUG esc failed
  ;; (keymap-set combobulate-proffer-map "ESC" 'cancel)
  ;; (keymap-set combobulate-proffer-map "C-e" 'cancel)
  )
#+end_src

** init end

#+begin_src emacs-lisp :lexical t
;; TODO write magika.el to identify file content with magika cmd
;;; init.el ends here
#+end_src

